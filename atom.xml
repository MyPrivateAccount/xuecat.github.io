<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2017-02-11T07:25:57.920Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++日常212</title>
    <link href="https://xuecat.github.io/2017/02/11/212/"/>
    <id>https://xuecat.github.io/2017/02/11/212/</id>
    <published>2017-02-11T07:22:46.000Z</published>
    <updated>2017-02-11T07:25:57.920Z</updated>
    
    <content type="html"><![CDATA[<p>for (int i : {0,1,2})<br>{ }<br>常数级的循环只能这样写了，感觉还好吧。</p>
<p>int p[5];<br>for each(int i in p)<br>这个常数级的循环真心没法优雅，留着以后再试试吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;for (int i : {0,1,2})&lt;br&gt;{ }&lt;br&gt;常数级的循环只能这样写了，感觉还好吧。&lt;/p&gt;
&lt;p&gt;int p[5];&lt;br&gt;for each(int i in p)&lt;br&gt;这个常数级的循环真心没法优雅，留着以后再试试吧。&lt;/p&gt;

    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>effective javsscript(211)</title>
    <link href="https://xuecat.github.io/2017/02/11/211/"/>
    <id>https://xuecat.github.io/2017/02/11/211/</id>
    <published>2017-02-11T07:15:38.000Z</published>
    <updated>2017-02-11T07:21:12.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><ol>
<li>(1+2)+”3” //“33”</li>
<li><p>当多个运算符被重载时，js会盲目的选择valueOf; 所以要么明确重载一个，要么保证重载的俩个值相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"hh"</span>;</div><div class="line">    &#125;,</div><div class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">12</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//或者 obj.prototype.toString = function () ...</span></div><div class="line"><span class="string">"object:"</span> + obj;<span class="comment">//"object:17"</span></div></pre></td></tr></table></figure>
</li>
<li><p>真值运算；if、|| 、&amp;&amp;需要布尔的运算<br>js有7个假值：false、0、-0、””、NaN、null、undefined；</p>
</li>
</ol>
<h3 id="的强制转换"><a href="#的强制转换" class="headerlink" title="== 的强制转换"></a>== 的强制转换</h3><table>
<thead>
<tr>
<th>Param1</th>
<th style="text-align:center">Param2</th>
<th style="text-align:right">Force Format</th>
</tr>
</thead>
<tbody>
<tr>
<td>null</td>
<td style="text-align:center">undefined</td>
<td style="text-align:right">不转换，总返回true</td>
</tr>
<tr>
<td>null or undefined</td>
<td style="text-align:center">非null、非undefined</td>
<td style="text-align:right">不转换，总返回false</td>
</tr>
<tr>
<td>原始类型</td>
<td style="text-align:center">Date对象、非Date对象</td>
<td style="text-align:right">原始类型转换为数字，Date对象（优先toString）、非Date对象(优先valueOf)转换为原始类型</td>
</tr>
<tr>
<td>原始类型</td>
<td style="text-align:center">原始类型</td>
<td style="text-align:right">将原始类型转换为数字</td>
</tr>
</tbody>
</table>
<h3 id="Unicode字符"><a href="#Unicode字符" class="headerlink" title="Unicode字符"></a>Unicode字符</h3><ol>
<li>js字符串由16位代码单元组成，而不是由unicode代码点组成。</li>
<li>js使用俩个代码单元表示16位以上的unicode代码点，称为代码对。</li>
<li>代码对甩开了字符串元素计数，length、charAt、charCodeAt方法以及正则表达式模式。</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSandwich</span>(<span class="params">maigc</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">filling</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> maigc + <span class="string">" and "</span> + filling;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> make;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = makeSandwich(<span class="string">"peanut butter"</span>);</div><div class="line">f(<span class="string">"jelly"</span>);<span class="comment">//"peanut butter and jelly"</span></div></pre></td></tr></table></figure>
<p>立即调用函数表达式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wara</span>(<span class="params">a</span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> result = [];</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, n = a.length; i &lt; n; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">    result[j] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> a[j];&#125;;</div><div class="line">  &#125;)(i);</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>js对变量的作用域是函数级的，不是块级的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">trime</span>(<span class="params">header</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; n = header; i &lt; n; i++)</div><div class="line">    ...</div><div class="line">    for (<span class="keyword">var</span> i = <span class="number">0</span>; n = header; i &lt; n; i++)</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//上面的i,n其实只申明了一次，剩下的都是同一个而已。js的变量提升可以视为会把声明自动放到函数开头。</span></div></pre></td></tr></table></figure></p>
<h3 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) ...</span></div><div class="line"><span class="title">function</span> <span class="title">test</span>(<span class="params"></span>) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) ... //在此函数里访问<span class="title">f</span>，就只会是这个<span class="title">f</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以建议少用命名函数，多用匿名函数。</p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><ol>
<li>书上的建议是不要用它创建变量，同名变量会导致访问相同地址的变量</li>
<li>间接调用eval函数；<br><code>(0,eval)(src)</code> 0值无意义以达到强制使用间接调用的目的。src是传入给eval的参数。</li>
</ol>
<h3 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h3><p>obj.temprorary = f;<br>var result = obj.temprorary(arg1, arg2);<br>delete obj.temprorary;<br>当想使用其他对象的某个属性时，这种方法不仅别扭，而且相当危险。<br>所以有了call和apply</p>
<p>apply只是让数组变成多个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> df = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> vf = <span class="function"><span class="keyword">function</span>(<span class="params">a1, a2, a3</span>) </span>&#123; <span class="keyword">return</span> (a1+a2+a3)/<span class="number">3</span>;&#125;</div><div class="line">vf.apply(vf, df)</div></pre></td></tr></table></figure></p>
<h3 id="js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。"><a href="#js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。" class="headerlink" title="js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。"></a>js函数有个arguments的默认参数，也是数组。所以默认支持变长参数函数。</h3><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> buffer = &#123;</div><div class="line"> entries: [],</div><div class="line"> add: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.entries.push(s);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sourc = [<span class="string">"874"</span>, <span class="string">"-"</span>, <span class="string">"53443"</span>];</div><div class="line">sourc.forEach(buffer.add.bind(buffer)) <span class="comment">//保证buffer.add函数的接受者就是buffer对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">simple</span>(<span class="params">pro, dom, path</span>) </span>&#123;</div><div class="line"> <span class="keyword">return</span> pro + <span class="string">"://"</span> + dom + <span class="string">"/"</span> + path;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> ul = apath.map(simple.bind(<span class="literal">null</span>, <span class="string">"http"</span>, <span class="string">"ff"</span>));<span class="comment">//["http://ff/we", "http://ff/er", "http://ff/rt"]</span></div><div class="line"><span class="comment">//bind第一个参数提供接受者的值，其余参数提供给给新函数的所有参数。</span></div></pre></td></tr></table></figure>
<h3 id="使构造函数与new无关"><a href="#使构造函数与new无关" class="headerlink" title="使构造函数与new无关"></a>使构造函数与new无关</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一般我们写构造函数时都喜欢，传入参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> x = User(<span class="string">"test"</span>, <span class="string">"demo"</span>);<span class="comment">//这样做虽然可以成功，但是也会产生多余的全局变量name和password</span></div><div class="line"></div><div class="line"><span class="comment">//避免有俩种方法，要么  var x = new User("test", "demo")</span></div><div class="line"><span class="comment">//所以要这么写函数，加不加new都可以</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">name, password</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> User))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(name, password);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.password = password;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将状态存储到示例对象而不是原型对象"><a href="#将状态存储到示例对象而不是原型对象" class="headerlink" title="将状态存储到示例对象而不是原型对象"></a>将状态存储到示例对象而不是原型对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = x;</div><div class="line">&#125;</div><div class="line">Tree.prototype = &#123;</div><div class="line">    children: [],</div><div class="line">    addChild: <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.children.push(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> left = <span class="keyword">new</span> Tree(<span class="number">2</span>);</div><div class="line">left.addChild(<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> right = <span class="keyword">new</span> Tree(<span class="number">6</span>);</div><div class="line">right.addChild(<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> top = <span class="keyword">new</span> Tree(<span class="number">7</span>);</div><div class="line">top.addChild(left);</div><div class="line">top.addChild(right);</div><div class="line">top.children; <span class="comment">//[1,4,left,right] 这样会多出俩个对象。所以把children放入成员变量是最好</span></div></pre></td></tr></table></figure>
<h3 id="this隐式绑定问题"><a href="#this隐式绑定问题" class="headerlink" title="this隐式绑定问题"></a>this隐式绑定问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CSVReader</span>(<span class="params">sep</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.regexp = ...;</div><div class="line">&#125;</div><div class="line">CSVReader.prototype.read = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lines = str.trim().split(<span class="regexp">/\n/</span>);</div><div class="line">    <span class="keyword">return</span> lines.map(<span class="function"><span class="keyword">function</span>(<span class="params">line</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> line.split(<span class="keyword">this</span>.regexp);<span class="comment">//此处本来是想访问CSVReader的regexp，但是实际访问的是lines的</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//改法加bind，或者 var self = this; .... self.regexp;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;隐式转换&quot;&gt;&lt;a href=&quot;#隐式转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换&quot;&gt;&lt;/a&gt;隐式转换&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;(1+2)+”3” //“33”&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当多个运算符被重载时，js会盲目的选择valueOf;
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="js语法" scheme="https://xuecat.github.io/tags/js%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C#文件和其它210</title>
    <link href="https://xuecat.github.io/2017/01/21/210/"/>
    <id>https://xuecat.github.io/2017/01/21/210/</id>
    <published>2017-01-21T08:36:46.000Z</published>
    <updated>2017-02-06T15:59:15.862Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/210.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>File和FileInfo<br>Directory和DirectoryInfo<br>如果执行单一调用使用静态类<br>如果执行一系列调用使用Info类</p>
<p><code>new FileInfo(@&quot;C:\Log.txt&quot;)</code>使用<code>@</code>前缀表示字符按字面意义解释，没有的话就要用<code>\\</code>代替<code>\</code>了。</p>
<p><code>FileStream</code>读写的是字节数组<br><code>StreamReader</code> <code>StreamWriter</code>读写的是字符数组<br>字符和数组的转换用<code>Decoder</code>和<code>Encoder</code></p>
<h3 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h3><ol>
<li><p>XPath 用于检索xml的节点。</p>
</li>
<li><p>创建xml的话，我绝对linq的XDocument要比XmlDocument好用多了。</p>
</li>
</ol>
<h3 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h3><p>它的实现是基于<code>IEnumerable&lt;T&gt;</code>接口,所以下面俩句是等效的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">string</span>[] name = &#123;<span class="string">"n1"</span>, <span class="string">"n2"</span>, <span class="string">"n3"</span>, <span class="string">"n4"</span> &#125;;</div><div class="line"><span class="keyword">var</span> dd = name.Where(n =&gt; n.StartsWith(<span class="string">"n"</span>));</div><div class="line"><span class="keyword">var</span> hh = <span class="keyword">from</span> n <span class="keyword">in</span> name <span class="keyword">where</span> n.StartsWith(<span class="string">"n"</span>) <span class="keyword">select</span> n;</div></pre></td></tr></table></figure></p>
<h4 id="orderby"><a href="#orderby" class="headerlink" title="orderby"></a>orderby</h4><p>暂时就个字母，其它排列再看看吧<br><code>var hh = from n in name where n.StartsWith(&quot;n&quot;) orderby n select n;</code>升序排列结果<br><code>var hh = from n in name where n.StartsWith(&quot;n&quot;) orderby n descending select n;</code>降序排列结果</p>
<h5 id="多级排序，并返回新建立的对象。"><a href="#多级排序，并返回新建立的对象。" class="headerlink" title="多级排序，并返回新建立的对象。"></a>多级排序，并返回新建立的对象。</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queryResults = from <span class="built_in">c</span> <span class="keyword">in</span> customers</div><div class="line"> orderby <span class="built_in">c</span>.<span class="type">Region</span>, <span class="built_in">c</span>.<span class="type">Country</span> descending, <span class="built_in">c</span>.<span class="type">City</span></div><div class="line"> select new &#123; <span class="built_in">c</span>.<span class="type">ID</span>, <span class="built_in">c</span>.<span class="type">Region</span>, <span class="built_in">c</span>.<span class="type">Country</span>, <span class="built_in">c</span>.<span class="type">City</span> &#125;;</div></pre></td></tr></table></figure>
<h4 id="查找不重复"><a href="#查找不重复" class="headerlink" title="查找不重复"></a>查找不重复</h4><p>会按照Region属性选出所有，Distinct来排除重复。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">qu</span> = name.Select(c =&gt; c.Region).<span class="keyword">Distinct</span>();</div><div class="line"><span class="keyword">var</span> <span class="keyword">qu</span> = (from c <span class="keyword">in</span> name select c.Region).<span class="keyword">Distinct</span>();</div></pre></td></tr></table></figure></p>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>书上的例子是，按照国家来比较销量<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> q =</div><div class="line"> from c <span class="keyword">in</span> customers</div><div class="line"> <span class="keyword">group</span> c <span class="keyword">by</span> c.Region <span class="keyword">into</span> cg</div><div class="line"> <span class="keyword">select</span> <span class="literal">new</span> &#123; TotalSaleds = cg.<span class="keyword">Sum</span>(c =&gt; c.Sales), Region = cg.Key&#125;</div><div class="line"></div><div class="line"> <span class="comment">//第二句by后面指定重组使用的Key，再重新组合成cg（即后面cg.Key）</span></div><div class="line"> <span class="comment">//第三句</span></div></pre></td></tr></table></figure></p>
<h4 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h4><p>书上的例子是把客户列表(customers)和订单列表(orders)中，id相同的找出重组合<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> q =</div><div class="line"> <span class="keyword">from</span> c <span class="keyword">in</span> customers</div><div class="line"> <span class="keyword">join</span> o <span class="keyword">in</span> orders <span class="keyword">on</span> c.ID <span class="keyword">equals</span> o.ID</div><div class="line"> <span class="keyword">select</span> <span class="keyword">new</span> <span class="comment">&#123;c.ID, c.City&#125;</span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET和wcf学习209</title>
    <link href="https://xuecat.github.io/2017/01/17/209/"/>
    <id>https://xuecat.github.io/2017/01/17/209/</id>
    <published>2017-01-17T14:58:11.000Z</published>
    <updated>2017-02-08T14:30:05.288Z</updated>
    
    <content type="html"><![CDATA[<p>###　ASP.NET Razor<br>书中也只是用一章来介绍它，vs有相关模板的建立！！<br>它和html连用，全名<code>cshtml</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###　ASP.NET Razor&lt;br&gt;书中也只是用一章来介绍它，vs有相关模板的建立！！&lt;br&gt;它和html连用，全名&lt;code&gt;cshtml&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="前端" scheme="https://xuecat.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Windows编译器对异常的处理207</title>
    <link href="https://xuecat.github.io/2017/01/12/207/"/>
    <id>https://xuecat.github.io/2017/01/12/207/</id>
    <published>2017-01-12T13:51:01.000Z</published>
    <updated>2017-01-12T14:35:30.161Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/207.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>c/c++ 配置属性 代码生成 启用c++异常</p>
<p>2013版本讲解要详细点：<br><a href="https://msdn.microsoft.com/zh-cn/library/1deeycx5(v=vs.120).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/1deeycx5(v=vs.120).aspx</a></p>
<p>编译器会对异常捕获进行优化。</p>
<p>使用<code>/EHs</code> <code>EHsc</code> catch(…) 是不会捕获异步结构化异常、访问冲突和 System.Exception 异常。只会捕获c++异常<br>当必须要捕获这些异常时，就只能用 <strong>try, </strong>except 和 __finally 语法</p>
<p>使用<code>/EHa</code> catch(…)会捕获所有的异常。<br>但是引用官方的话<code>指定 /EHa 并尝试使用 catch(...) 处理所有异常可能很危险。 在大多数情况下，异步异常是不可恢复的，因而被认为是致命的。 捕获它们并继续可能导致进程损坏并使 Bug 难以发现和修复。</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>加锁问题206</title>
    <link href="https://xuecat.github.io/2016/12/27/206/"/>
    <id>https://xuecat.github.io/2016/12/27/206/</id>
    <published>2016-12-27T14:19:35.000Z</published>
    <updated>2016-12-27T14:24:00.597Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/206.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>今天加临界区时讨论了下。<br>一开始觉得迭代器，写的地方加锁就好了。<br>但是后来发现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_VTRUploadTaskList.size(); i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(m_VTRUploadTaskList[i]<span class="number">._</span>nTaskID == nTaskID)</div><div class="line">&#125;</div><div class="line"><span class="comment">//这样，如果外部对这个clear的话，再走操作函数就会挂的。</span></div><div class="line"><span class="comment">//所以，结论是有关写的整块都要加锁</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="杂项" scheme="https://xuecat.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="mfc" scheme="https://xuecat.github.io/tags/mfc/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Gen2项目学习205</title>
    <link href="https://xuecat.github.io/2016/12/15/205/"/>
    <id>https://xuecat.github.io/2016/12/15/205/</id>
    <published>2016-12-15T12:51:59.000Z</published>
    <updated>2017-01-21T08:53:08.716Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/picture/u1.jpg" alt=""></div><div class="group-picture-column" style="width: 50%;"><img src="/picture/u2.jpg" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/u3.jpg" alt=""></div></div></div></div>
<h4 id="LoggingDBService"><a href="#LoggingDBService" class="headerlink" title="LoggingDBService"></a>LoggingDBService</h4><p>212失联后，为了配置这个服务，也是伤神死了。</p>
<p>1、服务是否正确。启动LoggingDBService，在网页上输入相应网址访问；再看看<code>asmx</code>访问是否成功，成功的话就表示服务是好的。</p>
<p>2、数据库配置是否正确。进入数据库，对比相应数据库名、用户名、和密码。</p>
<p>3、本地<code>webService.ini</code>是配置正确。要注意的是里面的ip地址必须是c类ip；回环ip和localhost之类的是不行的。</p>
<h3 id="logging的webservice"><a href="#logging的webservice" class="headerlink" title="logging的webservice"></a>logging的webservice</h3><p>他们用的是<code>asp.net webservice</code>工程。vs10以后，就全是<code>wcf</code>了。<br>如果要强制建，可以<code>空asp</code>再建个<code>web服务程序</code></p>
<p>类继承<code>MarshalByRefObject, IRegisteredObject</code>后，再访问<code>asmx</code>文件。就达到了服务程序，随winform程序启动的假象。<br>实际就是iis服务器。<br>不然就自己配置到iis服务器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="sobey项目" scheme="https://xuecat.github.io/tags/sobey%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>WPF学习204</title>
    <link href="https://xuecat.github.io/2016/12/07/204/"/>
    <id>https://xuecat.github.io/2016/12/07/204/</id>
    <published>2016-12-07T15:14:24.000Z</published>
    <updated>2017-02-02T02:12:07.128Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/y2.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="wpf和winform"><a href="#wpf和winform" class="headerlink" title="wpf和winform"></a>wpf和winform</h3><p>winform -&gt; 新建windows窗体程序<br>控件的描述全在一个<code>Designer</code>的cs文件中，控件事件则在对应的cs文件里。</p>
<p>wpf -&gt; 新建wpf程序</p>
<p>感觉winform就是基于mfc再封装了一层c#，界面设计等还是wpf吧</p>
<h3 id="代码隐藏文件"><a href="#代码隐藏文件" class="headerlink" title="代码隐藏文件"></a>代码隐藏文件</h3><p>界面描述放在<code>xaml</code>文件里的<br>为界面增加功能（事件呀等）的cs代码，就放入<code>.xaml.cs</code>文件中<br>隐藏文件默认是放入xaml文件同一个目录中的。</p>
<p>界面第一句：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Window</span> <span class="attr">x:Class</span>=<span class="string">"WpfApplication1.MainWindow"</span>&gt;</span></div><div class="line">//第一句就指定了，对应隐藏文件的类</div></pre></td></tr></table></figure></p>
<h3 id="路由事件"><a href="#路由事件" class="headerlink" title="路由事件"></a>路由事件</h3><p>路由事件有点想mfc的common，但是它要多点。<br>lbutondown这些事件是标准事件，它只会发给被显示订阅的控件。</p>
<p>像keydown这种路由事件它会：<br>先走下钻事件（Preview开头的事件），再走上钻事件（正常开头的事件）；<br>pre的Window事件-&gt;pre的Grid网格事件-&gt;pre的焦点控件事件-&gt;焦点控件事件-&gt;Grid网格事件-&gt;Window事件</p>
<p>如需要停止路由，直接<code>e.Handled = true;</code></p>
<h3 id="布局控件"><a href="#布局控件" class="headerlink" title="布局控件"></a>布局控件</h3><p>把这几个基本的布局控件搞了，就直接干代码了。太麻烦了！！</p>
<h4 id="Canvas控件"><a href="#Canvas控件" class="headerlink" title="Canvas控件"></a>Canvas控件</h4><p>书上说这个可以完全自由地对控件的位置进行安排，且<code>HorizontalAligment</code>和<code>VerticalAlignment</code>并不能改变这些元素位置</p>
<p>测试发现，窗口的变大变小如果是Grid则会跟随变化里面子控件的大小；而Canvas则不会，里面的子控件大小位置被固定了似的。</p>
<p>可以用<code>Canvas.Top</code>等这些属性来限定子控件在<code>Canvas</code>里面的布局，但我估计实际应用慢慢看吧。。。。</p>
<h4 id="DockPanel控件"><a href="#DockPanel控件" class="headerlink" title="DockPanel控件"></a>DockPanel控件</h4><p>它会从上往下（越接近顶层，越优先）。布局子控件，除非有限制（height、width），不然会尽量布满布局。</p>
<p>它是从剩余空间来进行计算(<code>DockPanel.Dock=&quot;Top&quot;</code>以剩余的上半部分为基础)</p>
<h4 id="StackPanel控件"><a href="#StackPanel控件" class="headerlink" title="StackPanel控件"></a>StackPanel控件</h4><p>它的设置更多的设置本身，它来控制内部子控件的堆叠方向，不会占满布局。</p>
<p>用<code>Orientaion、VerticalAlignment、HorizontalAlignment</code>来设置内部控件的堆叠方向、内部控件对齐方向。</p>
<h4 id="WrapPanel控件"><a href="#WrapPanel控件" class="headerlink" title="WrapPanel控件"></a>WrapPanel控件</h4><p>是StackPanel的扩展版本；容纳不下的控件会被安排到下一行</p>
<h4 id="Grid控件"><a href="#Grid控件" class="headerlink" title="Grid控件"></a>Grid控件</h4><h3 id="透明窗口"><a href="#透明窗口" class="headerlink" title="透明窗口"></a>透明窗口</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//窗口透明</span></div><div class="line">WindowStyle=<span class="string">"None"</span></div><div class="line">AllowsTransparency=<span class="string">"True"</span></div><div class="line">Background=<span class="string">"Transparent"</span><span class="comment">//这个属性感觉很智能，它还可以设置窗体的透明色。</span></div><div class="line"></div><div class="line"><span class="comment">//控件透明</span></div><div class="line"><span class="comment">//另外控件的透明度用 Opacity</span></div></pre></td></tr></table></figure>
<h3 id="控件标题内容换行"><a href="#控件标题内容换行" class="headerlink" title="控件标题内容换行"></a>控件标题内容换行</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Content</span>=<span class="string">"wrewrwere&amp;#13;wrewrewrwe"</span></div><div class="line"><span class="attr">Text</span>=<span class="string">"oiomlkljoijlo&amp;#x0a;klklkkjkjjk"</span></div></pre></td></tr></table></figure>
<p>如上，很方便。但还是纠结了，本来Windows换行符是<code>\r\n</code>的，c#代码换行也是如此。<br>于是有下：<br>空格 (&#x0020;)<br>Tab (&#x0009;)<br>回车 (&#x000D;) 难怪上面是13<br>换行 (&#x000A;)</p>
<h3 id="高宽百分比设置"><a href="#高宽百分比设置" class="headerlink" title="高宽百分比设置"></a>高宽百分比设置</h3><p>今天试了下，发现 Height和Width 不仅可以用数字表示，还可以 <code>30*</code>这种百分比表示。</p>
<p>这样的话就会把所有子控件的加上，再除以相应数字。得出百分比，进行布局设置。</p>
<h3 id="grid跨行跨列"><a href="#grid跨行跨列" class="headerlink" title="grid跨行跨列"></a>grid跨行跨列</h3><p>对于grid可以分区：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//行的使用</div><div class="line"><span class="tag">&lt;<span class="name">Grid.RowDefinitions</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"34"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RowDefinition</span> <span class="attr">Height</span>=<span class="string">"24"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Grid.RowDefinitions</span>&gt;</span></div><div class="line">//子控件使用 Grid.Row="0" 等语法就可以放置到相应区里面</div></pre></td></tr></table></figure></p>
<p>但是当有个控件比较特殊，需要占多个行或列时（上面grid划分好了的行和列）<br>就可以使用<code>Grid.RowSpan（列同理）</code> 它会从 <code>Grid.Row（列同理）</code>开始，占满接下来几个的行（列）</p>
<h3 id="x命名空间"><a href="#x命名空间" class="headerlink" title="x命名空间"></a>x命名空间</h3><h3 id="tab控件使用"><a href="#tab控件使用" class="headerlink" title="tab控件使用"></a>tab控件使用</h3><p>注意TabItem子控件只能有一个，所以一般用布局控件来代替。</p>
<h3 id="x-Name和Name"><a href="#x-Name和Name" class="headerlink" title="x:Name和Name"></a>x:Name和Name</h3><p>所有的Type在xaml中都能使用x:Name,即使这个type 没有定义一个叫着Name的Property。<br>因为xmal会在后台为其分配一个field来存储，以便在Binding等里面使用。</p>
<p>像FrameworkElement, VisualStateGroup的某些type，我们在xaml中可以使用Name来代替x:Name，<br>因为它们定义了Name Property，但是最关键的是在type上声明了一个Attribute，[RuntimeNameProperty(“Name”)]，<br>正是这个attribute把Name映射到了x:Name上，所以让Name可以做到x:Name的功能。</p>
<p>正因为如此，name属性超级好用，在xaml给个name属性，相应的隐藏文件就可以直接使用此name来代表此控件</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p><a href="https://www.tutorialspoint.com/wpf" target="_blank" rel="external">https://www.tutorialspoint.com/wpf</a><br><a href="https://msdn.microsoft.com/zh-cn/library/ms752347(v=vs.110).aspx" target="_blank" rel="external">https://msdn.microsoft.com/zh-cn/library/ms752347(v=vs.110).aspx</a></p>
<p><code>Content=&quot;{Binding}&quot;</code> <a href="https://technet.microsoft.com/zh-cn/subscriptions/index/system.windows.controls.contentcontrol.contenttemplate(v=vs.95" target="_blank" rel="external">默认关联属性</a>.aspx)</p>
<h4 id="本地对象绑定"><a href="#本地对象绑定" class="headerlink" title="本地对象绑定"></a>本地对象绑定</h4><p>如上所说，绑定和<code>Name</code>相关。</p>
<p>先看本地对象绑定：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">CheckBox</span> <span class="attr">Name</span>=<span class="string">"ee"</span> <span class="attr">Content</span>=<span class="string">"Play against computer"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">Margin</span>=<span class="string">"8,2,0,0"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">Label</span> <span class="attr">Content</span>=<span class="string">"Number"</span> <span class="attr">Margin</span>=<span class="string">"8,28,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">IsEnabled</span>=<span class="string">"</span></span><span class="template-variable">&#123;Binding ElementName=ee, Path=IsChecked&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> /&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">ComboBox</span> <span class="attr">x:Name</span>=<span class="string">"hhe"</span> <span class="attr">Width</span>=<span class="string">"86"</span> <span class="attr">Margin</span>=<span class="string">"180,28,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> <span class="attr">SelectedIndex</span>=<span class="string">"0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ComboBoxItem</span>&gt;</span>2<span class="tag">&lt;/<span class="name">ComboBoxItem</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ComboBoxItem</span>&gt;</span>3<span class="tag">&lt;/<span class="name">ComboBoxItem</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ComboBox</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">TextBox</span> <span class="attr">Text</span>=<span class="string">"</span></span><span class="template-variable">&#123;Binding ElementName=hhe, Path=SelectedItem.Content&#125;</span><span class="xml"><span class="tag"><span class="string">"</span> <span class="attr">Width</span>=<span class="string">"86"</span> <span class="attr">Margin</span>=<span class="string">"180,68,0,0"</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Left"</span> <span class="attr">VerticalAlignment</span>=<span class="string">"Top"</span> /&gt;</span></span></div><div class="line"></div><div class="line">//如下形式是同样的</div><div class="line"><span class="tag">&lt;<span class="name">ComboBox.IsEnabled</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Binding</span> <span class="attr">ElementName</span>=<span class="string">"ee"</span> <span class="attr">Path</span>=<span class="string">"IsChecked"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ComboBox.IsEnabled</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>先看<code>Label</code>的绑定，<code>Binding</code>通过<code>ElementName</code>的<code>Name</code>属性找到了<code>CheckBox</code>对象，并绑定到它身上，再通过<code>IsChecked</code>属性来传值。实际效果：check选中，label就enable（相反同理）<br>再看<code>TextBox</code>绑定，<code>Binding</code>还是绑定到<code>ComboBox</code>上，且它文本绑定到了选中的内容上。实际效果：<code>ComboBox</code>选中哪项，<code>TextBox</code>就显示相应的选中内容。</p>
<h4 id="静态绑定到外部对象"><a href="#静态绑定到外部对象" class="headerlink" title="静态绑定到外部对象"></a>静态绑定到外部对象</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态资源的定义最好尽量放外面，不然识别不到外部类</span></div><div class="line">&lt;Grid.Resources&gt;</div><div class="line">    &lt;<span class="keyword">local</span>:ComBoxTests x:<span class="built_in">Key</span>=<span class="string">"com"</span>&gt;&lt;/<span class="keyword">local</span>:ComBoxTests&gt;</div><div class="line">&lt;/Grid.Resources&gt;</div><div class="line"></div><div class="line">&lt;ComboBox x:Name=<span class="string">"hhe"</span> Width=<span class="string">"86"</span> <span class="built_in">Margin</span>=<span class="string">"180,28,0,0"</span> HorizontalAlignment=<span class="string">"Left"</span> VerticalAlignment=<span class="string">"Top"</span> SelectedIndex=<span class="string">"0"</span> ItemsSource=<span class="string">"&#123;Binding Source=&#123;StaticResource com&#125;&#125;"</span>&gt;</div><div class="line">&lt;/ComboBox&gt;</div><div class="line">&lt;TextBox Text=<span class="string">"&#123;Binding ElementName=hhe, Path=SelectedItem&#125;"</span> Width=<span class="string">"86"</span> <span class="built_in">Margin</span>=<span class="string">"180,68,0,0"</span> HorizontalAlignment=<span class="string">"Left"</span> VerticalAlignment=<span class="string">"Top"</span> GotFocus=<span class="string">"TimeTextBox_GotFocus"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">//代码方面</span></div><div class="line">public class ComBoxTests : ObservableCollection&lt;<span class="keyword">string</span>&gt;</div><div class="line">&#123;</div><div class="line">    public ComBoxTests()</div><div class="line">        : base()</div><div class="line">    &#123;</div><div class="line">        Add(<span class="string">"str1"</span>);</div><div class="line">        Add(<span class="string">"str2"</span>);</div><div class="line">        Add(<span class="string">"str3"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/////再来个例子</span></div><div class="line">&lt;sys1:<span class="keyword">String</span> x:<span class="built_in">Key</span>=<span class="string">"Name"</span>&gt;sunji&lt;/sys1:<span class="keyword">String</span>&gt;</div><div class="line">&lt;TextBlock Name=<span class="string">"txtbName"</span> Text=<span class="string">"&#123;StaticResource Name&#125;"</span>/&gt;</div></pre></td></tr></table></figure>
<p>如上，向combobox添加了三个选项，但是<code>TextBox</code>的内部绑定却不得不改了，我也不知道。。想说绑定规则太多了。。。</p>
<h5 id="Mode的类型"><a href="#Mode的类型" class="headerlink" title="Mode的类型"></a>Mode的类型</h5><p>Mode = OneWay 就仅仅只是绑定，控件修改的数据也不会更新到绑定对象里面去<br>Mode = TwoWay 绑定后，若控件修改了数据也会更新到绑定的对象上面去。<br>Mode = OneWayToSource 依赖性只更新到绑定对象上面去。</p>
<p>详细看：<a href="https://www.tutorialspoint.com/wpf/wpf_data_binding.htm" target="_blank" rel="external">https://www.tutorialspoint.com/wpf/wpf_data_binding.htm</a></p>
<h4 id="动态绑定到外部对象"><a href="#动态绑定到外部对象" class="headerlink" title="动态绑定到外部对象"></a>动态绑定到外部对象</h4><p>对于双向绑定来说这个是必须的。<br>重写INotifyPropertyChanged接口</p>
<p><strong>来区分下INotifyPropertyChanged和mode</strong><br>如上，mode有三种模式不多讲了。<br>1、只重写INotifyPropertyChanged接口，确实能进行双向绑定。<br>2、只设置Mode = TwoWay也可以双向绑定。<br>但是它们有个区别。第二种情况，当数据更新时，它并不会立刻更新界面；要等界面再来取一次才行。第一种情况mode就默认了为TwoWay</p>
<p>所以mode和INotifyPropertyChanged配合才是最好的</p>
<h3 id="Menu控件"><a href="#Menu控件" class="headerlink" title="Menu控件"></a>Menu控件</h3><p>这个控件可以像其他控件那样，随便放哪个地方，然后自己设置menu内容。<br><code>Menu.Icon</code>设置单个选项的图标。<br><code>InputGestureText</code>只是个显示内容，不会和指令绑定。<br><code>Click</code>子项直接相应此属性的函数就好了。</p>
<h4 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h4><p>多说项:CanExecute返回false，会自动把控件设置为禁止状态。</p>
<p>先看下默认的，主要讲下：</p>
<p>Command，确实它能和指令绑定，但是默认只能和wpf能解析的指令绑定（自定义命令，下次再讲述吧）。<br>它设置命令后，如果想拦截命令的执行：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">...</span> <span class="attr">Command</span>=<span class="string">"Save"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">Window.CommandBindings</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">CommandBinding</span> <span class="attr">Command</span>=<span class="string">"Save"</span> <span class="attr">CanExecute</span>=<span class="string">"NewCommand_CanExecute"</span> <span class="attr">Executed</span>=<span class="string">"NewCommand_Executed"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Window.CommandBindings</span>&gt;</span></div><div class="line">//CanExecute 是开始展开menu时执行函数，以此来判断哪些项不允许点击和点击</div><div class="line">//Executed 是点击了menuitme是执行的函数</div></pre></td></tr></table></figure></p>
<p>自定义command主要有俩种：</p>
<ol>
<li><p>自定义<code>ICommand</code></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyCommand : ICommand</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> event EventHandler CanExecuteChanged</div><div class="line">    &#123;</div><div class="line">        add &#123; CommandManager.RequerySuggested += value; &#125;</div><div class="line">        remove &#123; CommandManager.RequerySuggested -= value; &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> CanExecute(object parameter)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Execute(object parameter)</div><div class="line">    &#123;</div><div class="line">        MessageBox.Show(<span class="string">"www"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">调用时：</div><div class="line">要么：<span class="keyword">this</span>.btn.Command = <span class="keyword">new</span> MyCommand();或者&lt;Button Command=<span class="string">"&#123;Binding MyCommand&#125;</span></div><div class="line">要么：&lt;local:MyCommand x:Key="ww<span class="string">" /&gt; &lt;Button Command="</span>&#123;StaticResource ww&#125;<span class="string">" /&gt;</span></div><div class="line">这种`Command`信息比较少，适合默认执行类型。真要加信息也得加`CommandParameter`</div></pre></td></tr></table></figure>
</li>
<li><p>自定义<code>RoutedCommand</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> RoutedCommand RMyCommand =</div><div class="line">    <span class="keyword">new</span> RoutedCommand(<span class="string">"MYC"</span>, <span class="keyword">typeof</span>(ForTest));</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForTest</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    InitializeComponent();</div><div class="line">    tc.Command = RMyCommand;</div><div class="line">    </div><div class="line">    CommandBinding comBind = <span class="keyword">new</span> CommandBinding();</div><div class="line">    comBind.Command = RMyCommand;</div><div class="line">    comBind.CanExecute += <span class="keyword">new</span> CanExecuteRoutedEventHandler(cb_CanExecute);</div><div class="line">    comBind.Executed += <span class="keyword">new</span> ExecutedRoutedEventHandler(cb_Execute);</div><div class="line"></div><div class="line">    gg.CommandBindings.Add(comBind);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cb_Execute</span>(<span class="params"><span class="keyword">object</span> sender, ExecutedRoutedEventArgs e</span>)</span></div><div class="line">&#123;</div><div class="line">    tb.Clear();</div><div class="line">    e.Handled = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cb_CanExecute</span>(<span class="params"><span class="keyword">object</span> sender, CanExecuteRoutedEventArgs e</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(tb.Text))</div><div class="line">    &#123;</div><div class="line">        e.CanExecute = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        e.CanExecute = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    e.Handled = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">如上，用`RoutedCommand`新建一个（第三个参数是快捷键）；</div><div class="line">大部分是多余的，和默认相比，中心思想就是新建一个command，添加到绑定。</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="渐变画刷"><a href="#渐变画刷" class="headerlink" title="渐变画刷"></a>渐变画刷</h3><h4 id="LinearGradientBrush"><a href="#LinearGradientBrush" class="headerlink" title="LinearGradientBrush"></a>LinearGradientBrush</h4><p>我在自定义控件界面时，想对背景色渐变。<br>这个是线性渐变，默认渐变线是对角线。<br>用startpoint endpoint来设置渐变线。<br>GradientStop 它表示渐变停止点，Offset来设置渐变线中百分比的偏移量（如：offset=”0.0” 这个点是从对角线左上开始的，有下个点它就停止在下个点的offset）</p>
<h4 id="RadialGradientBrush"><a href="#RadialGradientBrush" class="headerlink" title="RadialGradientBrush"></a>RadialGradientBrush</h4><p>这个是个圆形的渐变。<br>渐变线就是圆的各个半径。<br>Center书面说它是圆的中心（这个指的是圆形状的中心），可以想象它是控制所有圆的宽窄，通过它来控制所有圆心<br>GradientOrigin渐变色开始位置（可以从圆边，和圆心）<br>RadiusX、RadiusY这俩个是半径</p>
<h3 id="样式和模板"><a href="#样式和模板" class="headerlink" title="样式和模板"></a>样式和模板</h3><p>样式：<a href="http://www.wpf-tutorial.com/styles/using-styles/" target="_blank" rel="external">http://www.wpf-tutorial.com/styles/using-styles/</a><br>分层、显隐式（x:Key; Style=”{StaticResource HeaderStyle}”）<br>//可以同一设置控件的属性内容</p>
<h4 id="控件模板"><a href="#控件模板" class="headerlink" title="控件模板"></a>控件模板</h4><p>模板：<a href="http://www.cnblogs.com/dingli/archive/2011/07/20/2112150.html" target="_blank" rel="external">http://www.cnblogs.com/dingli/archive/2011/07/20/2112150.html</a><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">Style</span> TargetType=<span class="string">"Button"</span>&gt;</div><div class="line">    &lt;<span class="keyword">Setter</span> <span class="keyword">Property</span>=<span class="string">"Template"</span>&gt;</div><div class="line">        &lt;<span class="keyword">Setter</span>.<span class="keyword">Value</span>&gt;</div><div class="line">            &lt;ControlTemplate TargetType=<span class="string">"Button"</span>&gt;</div><div class="line">            ...</div><div class="line"></div><div class="line">//通过ControlTemplate的VisualTree内容，可以重做控件外观模板</div><div class="line">//通过tigger，&lt;ControlTemplate.Triggers&gt; &lt;<span class="keyword">Trigger</span> <span class="keyword">Property</span>=<span class="string">"IsMouseOver"</span> <span class="keyword">Value</span>=<span class="string">"true"</span>&gt; ，可以对控件的事件作出响应</div><div class="line">//控件内容显示用ContentPresenter要比ContentControl轻量一些</div></pre></td></tr></table></figure></p>
<h3 id="转换接口"><a href="#转换接口" class="headerlink" title="转换接口"></a>转换接口</h3><p>对于静态绑定到内部对象太重要了，这个接口。<br>比如：通过输入<code>no</code>，来禁止控件；一个是字符一个是bool，绑定就不会成功，所以需要转换。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">local</span>:Convert x:<span class="built_in">Key</span>=<span class="string">"toconvert"</span>&gt;&lt;/<span class="keyword">local</span>:Convert&gt;</div><div class="line">&lt;RadioButton IsEnabled=<span class="string">"&#123;Binding ElementName=tbt, Path=Content, Converter=&#123;StaticResource toconvert&#125;&#125;"</span> /&gt;</div><div class="line"></div><div class="line"><span class="comment">//上面是cs文件处理，代码上继承IValueConverter自己转换便好</span></div><div class="line"><span class="comment">//由于上面是单向绑定，所以实现Convert便好</span></div><div class="line"><span class="comment">//当面对双向绑定时，ConvertBack也需要同时实现</span></div></pre></td></tr></table></figure>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>使用的结构也比较多，简单说下：<br>动画必须放入模板里面<code>Storyboard</code>,这样一个模板可以包含多个动画可以同时触发。<br>触发方式有俩种：<br>1、放入EventTrigger进行触发，只是要多个<code>BeginStoryboard</code>这样才能表示为此事件发生，模板开始触发。<br>2、放入<code>Resources</code>内（这个时候只需要<code>Storyboard</code>就够了）。因为有name属性，代码里面直接：<code>name.Begin()</code>，模板开始触发。</p>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><p>custom control有点没看透，直接讲user control。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">region</span> 属性</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> DependencyProperty ShowStringProperty =</div><div class="line">    DependencyProperty.Register(<span class="string">"ShowString"</span>, <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(UserTest),</div><div class="line">        <span class="keyword">new</span> PropertyMetadata(<span class="string">"默认值"</span>, <span class="keyword">new</span> PropertyChangedCallback(OnChangeShowString)));</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnChangeShowString</span>(<span class="params">DependencyObject obj, DependencyPropertyChangedEventArgs args</span>)<span class="comment">//设置属性被修改时的回调函数</span></span></div><div class="line">&#123;</div><div class="line">    UserTest tt = obj <span class="keyword">as</span> UserTest;</div><div class="line">    tt.t1.Text = (<span class="keyword">string</span>)args.NewValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">string</span> ShowString</div><div class="line">&#123;</div><div class="line">    <span class="keyword">set</span> &#123; SetValue(ShowStringProperty, <span class="keyword">value</span>); &#125;</div><div class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> (<span class="keyword">string</span>)GetValue(ShowStringProperty); &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">region</span> 事件</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">readonly</span> RoutedEvent ShowStringEvent =</div><div class="line">    EventManager.RegisterRoutedEvent(<span class="string">"ShowEvent"</span>, RoutingStrategy.Bubble,</div><div class="line">        <span class="keyword">typeof</span>(RoutedPropertyChangedEventHandler&lt;<span class="keyword">object</span>&gt;), <span class="keyword">typeof</span>(UserTest));</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">event</span> RoutedPropertyChangedEventHandler&lt;<span class="keyword">object</span>&gt; ShowEvent</div><div class="line">&#123;</div><div class="line">    add &#123; AddHandler(ShowStringEvent, <span class="keyword">value</span>); &#125;</div><div class="line">    remove &#123; RemoveHandler(ShowStringEvent, <span class="keyword">value</span>); &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BtnClickme</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)<span class="comment">//这是自定义控件给button加了个事件，这样这个函数就会通知外面我的自定义事件</span></span></div><div class="line">&#123;</div><div class="line">    RoutedPropertyChangedEventArgs&lt;<span class="keyword">object</span>&gt; arg =</div><div class="line">        <span class="keyword">new</span> RoutedPropertyChangedEventArgs&lt;<span class="keyword">object</span>&gt;(sender, e, ShowStringEvent);</div><div class="line">    RaiseEvent(arg);</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endregion</span></span></div><div class="line">&lt;local:UserTest HorizontalAlignment=<span class="string">"Center"</span> VerticalAlignment=<span class="string">"Bottom"</span> ShowString=<span class="string">"wangqiu"</span> ShowEvent=<span class="string">"UserTest_ShowEvent"</span> &gt;&lt;/local:UserTest&gt;</div></pre></td></tr></table></figure>
<p>都是先注册静态变量创建，再编写属性设置。</p>
<h4 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h4><p>wpf的控件是有共享的内存的，所以上面属性注册全用依赖属性注册。<br>官方说转换的时候 DependencyProperty.UnsetValue 会清空当前属性值。null 传给依赖属性是不行的，会被寻找其它值。</p>
<h3 id="ControlTemplate和ContentTemplate"><a href="#ControlTemplate和ContentTemplate" class="headerlink" title="ControlTemplate和ContentTemplate"></a>ControlTemplate和ContentTemplate</h3><p>前者可以改变控件的外形。后者改变控件的内容。<br>比如你的button，想变成圆形，就用前者。你想<code>Content=&quot;asasas&quot;</code>这些内容圆形显示时就用后者。</p>
<p>由于强大的xaml，使的内容和形状都可以用控件表述。但是表述内容和DataTemplate联合无疑是好的选择: <a href="http://www.cnblogs.com/zhouhb/p/3284827.html" target="_blank" rel="external">http://www.cnblogs.com/zhouhb/p/3284827.html</a></p>
<h3 id="ZIndex"><a href="#ZIndex" class="headerlink" title="ZIndex"></a>ZIndex</h3><p>数字越小则层数越低，数字最大的在最前面</p>
<h3 id="RenderTransform"><a href="#RenderTransform" class="headerlink" title="RenderTransform"></a>RenderTransform</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Label.RenderTransform</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">RotateTransform</span> <span class="attr">Angle</span>=<span class="string">"180"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Label.RenderTransform</span>&gt;</span></div></pre></td></tr></table></figure>
<p>1、RotateTransform：元素旋转：</p>
<blockquote>
<p>Angle：旋转角度。<br>CenterX：旋转水平中心。<br>CenterY旋转的垂直中心}这两个是绝对定位坐标，<br>而RenderTransformOrigin是相对定位的</p>
</blockquote>
<p>2、ScaleTransform：会对元素水平，垂直方向上缩放。</p>
<blockquote>
<p>CenterX：缩放水平中心。CenterY缩放的垂直中心<br>ScaleX：水平缩放倍数 ScaleY：垂直缩放倍数。</p>
</blockquote>
<p>3、SkewTransform：元素倾斜：</p>
<blockquote>
<p>CenterX：倾斜水平中心。CenterY倾斜的垂直中心<br>AngleX：水平倾斜角度。AngleY：垂直倾斜角度。</p>
</blockquote>
<p>4、TranslateTransform：元素移动(只对RenderTransform有效果)</p>
<blockquote>
<p>X=水平移动像素，Y=垂直移动像素。</p>
</blockquote>
<h3 id="OpacityMask"><a href="#OpacityMask" class="headerlink" title="OpacityMask"></a>OpacityMask</h3><p>简单形状的渐变直接fill渐变画刷就好了（而且画刷颜色直接指定透明度）。<br>可是路径和图片也要渐变的改变透明度只能用<code>OpacityMask</code></p>
<p><code>Opacity</code>是指定控件的透明度</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Image.OpacityMask</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">LinearGradientBrush</span> <span class="attr">StartPoint</span>=<span class="string">"0,0"</span> <span class="attr">EndPoint</span>=<span class="string">"0,1"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Color</span>=<span class="string">"#FFFFFFFF"</span> <span class="attr">Offset</span>=<span class="string">"0"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">GradientStop</span> <span class="attr">Color</span>=<span class="string">"#00FFFFFF"</span> <span class="attr">Offset</span>=<span class="string">"1"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">LinearGradientBrush</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">Image.OpacityMask</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>在 WPF 中绝大部分控件都继承自 DispatcherObject，<br>甚至包括 Application。这些继承自 DispatcherObject 的对象具有线程关联特征，<br>也就意味着只有创建这些对象实例，且包含了 Dispatcher 的线程(通常指默认 UI 线程)才能直接对其进行更新操作</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
      <category term="wpf" scheme="https://xuecat.github.io/tags/wpf/"/>
    
  </entry>
  
  <entry>
    <title>c#入门经典(3)203</title>
    <link href="https://xuecat.github.io/2016/12/06/203/"/>
    <id>https://xuecat.github.io/2016/12/06/203/</id>
    <published>2016-12-06T12:37:27.000Z</published>
    <updated>2016-12-10T07:41:35.517Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/y1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[DebuggerStepThrough]<span class="comment">//调试跳过下面方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DullMethod</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line"></div><div class="line">[DoesInterestingThings(<span class="number">1000</span>, WhatDoesItDo = <span class="string">"voodoo"</span>)]</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> DecoratedClass &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T Sum&lt;T&gt;(params T[] Args)</div><div class="line">&#123;</div><div class="line">    T sum = Args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Args.Length; ++i)</div><div class="line">    &#123;</div><div class="line">         sum += Args[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;<span class="comment">//上面这一段代码并不会编译通过</span></div></pre></td></tr></table></figure>
<p>在C++中这是最最基本的函数模板，但是在C#中代码通不过，<br>因为泛型不是模板，它不会生成多份代码，T是当做object来处理的，<br>因此不能用来进行加法运算。</p>
<p>##所以c#又引入了动态类型的概念##<br>便可以如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> T Sum&lt;T&gt;(params T[] Args)</div><div class="line">&#123;</div><div class="line">    dynamic sum = Args[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Args.Length; ++i)</div><div class="line">    &#123;</div><div class="line">         sum += Args[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C#编译器允许你通过dynamic对象调用任何方法，即使这个方法根本不存在，<br>编译器也不会在编译的时候报编译错误。只有在运行的时候，<br>它才会检查这个对象的实际类型</p>
<p>再看一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Duck</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">QQ</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(<span class="string">"qq"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"qq"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Humen</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GG</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Console.WriteLine(<span class="string">"gg"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"gg"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Program</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DoQG</span><span class="params">(dynamic dy)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">string</span> result = dy.GG();<span class="comment">//由于是dynamic，所以任何代码都是对的，编译器更不会报错</span></div><div class="line">        <span class="keyword">return</span> result ?? <span class="string">"hehe"</span>;<span class="comment">//但是执行的话，由于duck类是没有GG这个函数的。会直接抛出异常。</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></div><div class="line">    &#123;</div><div class="line">        Duck duck = <span class="keyword">new</span> Duck();</div><div class="line">        Humen hu = <span class="keyword">new</span> Humen();</div><div class="line"></div><div class="line">        Console.WriteLine(DoQG(hu));</div><div class="line">        Console.WriteLine(DoQG(duck));</div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="LINQ-Language-Integrated-Query"><a href="#LINQ-Language-Integrated-Query" class="headerlink" title="LINQ(Language Integrated Query)"></a>LINQ(Language Integrated Query)</h3><p>它使得查询语句可以像数据库那样执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int[] scores = new int[] &#123; 97, 92, 81, 60 &#125;;</div><div class="line">IEnumerable&lt;int&gt; sc = from score in scores where</div><div class="line">                        score &gt; 80 select score;</div><div class="line">//如果自定义类型要如此的话，必须重写IEnumerable&lt;T&gt;接口</div></pre></td></tr></table></figure></p>
<p>太多了，先跳过吧！</p>
<h3 id="释放非托管的资源"><a href="#释放非托管的资源" class="headerlink" title="释放非托管的资源"></a>释放非托管的资源</h3><p>c#的析构函数使用较少，释放的时机和位置由于不确定。<br>官方建议用<code>IDisposable</code>接口来代替析构函数(用于准确释放资源)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Myclass : IDisposable</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其用法有俩种</span></div><div class="line"></div><div class="line">Myclass dd = null;</div><div class="line"><span class="keyword">try</span> </div><div class="line">&#123;</div><div class="line">    dd = <span class="keyword">new</span> Myclass();</div><div class="line">    ...</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;</div><div class="line">finally</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dd)</div><div class="line">        dd.Dispose();</div><div class="line">&#125;</div><div class="line"><span class="comment">//以上做法保证了无论执行是否成功或异常，都要赶紧释放资源。唯一的确定就是写法太繁杂</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> (Myclass dd = <span class="keyword">new</span> Myclass())</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;<span class="comment">//如此写法就可以到相同效果</span></div></pre></td></tr></table></figure></p>
<hr>
<p>再说明下：<br>托管资源：由CLR管理分配和释放的资源，即由CLR里new出来的对象；<br>非托管资源：不受CLR管理的对象，windows内核对象，如文件、数据库连接、套接字、COM对象、gdi对象等；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> SampleClass : IDisposable</div><div class="line">&#123;</div><div class="line">    <span class="comment">//演示创建一个非托管资源</span></div><div class="line">    <span class="keyword">private</span> IntPtr nativeResource = Marshal.AllocHGlobal(<span class="number">100</span>);</div><div class="line">    <span class="comment">//演示创建一个托管资源</span></div><div class="line">    <span class="keyword">private</span> AnotherResource managedResource = <span class="keyword">new</span> AnotherResource();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> disposed = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 实现IDisposable中的Dispose方法</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//必须为true</span></div><div class="line">        Dispose(<span class="literal">true</span>);</div><div class="line">        <span class="comment">//通知垃圾回收机制不再调用终结器（析构器）</span></div><div class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 不是必要的，提供一个Close方法仅仅是为了更符合其他语言（如C++）的规范</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Close</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Dispose();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 必须，以备程序员忘记了显式调用Dispose方法</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    ~SampleClass()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//必须为false</span></div><div class="line">        Dispose(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// &lt;summary&gt;</span></div><div class="line">    <span class="comment">/// 非密封类修饰用protected virtual</span></div><div class="line">    <span class="comment">/// 密封类修饰用private</span></div><div class="line">    <span class="comment">/// &lt;/summary&gt;</span></div><div class="line">    <span class="comment">/// &lt;param name="disposing"&gt;&lt;/param&gt;</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Dispose</span><span class="params">(<span class="keyword">bool</span> disposing)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (disposed)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (disposing)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 清理托管资源</span></div><div class="line">            <span class="keyword">if</span> (managedResource != null)</div><div class="line">            &#123;</div><div class="line">                managedResource.Dispose();</div><div class="line">                managedResource = null;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 清理非托管资源</span></div><div class="line">        <span class="keyword">if</span> (nativeResource != IntPtr.Zero)</div><div class="line">        &#123;</div><div class="line">            Marshal.FreeHGlobal(nativeResource);</div><div class="line">            nativeResource = IntPtr.Zero;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//让类型知道自己已经被释放</span></div><div class="line">        disposed = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SamplePublicMethod</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (disposed)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ObjectDisposedException(<span class="string">"SampleClass"</span>, <span class="string">"SampleClass is disposed"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//省略</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重写Dispose接口为了及时释放非托管资源。<br>编写析构函数为了确保CLR的自动释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>c#入门经典(2)202</title>
    <link href="https://xuecat.github.io/2016/12/01/202/"/>
    <id>https://xuecat.github.io/2016/12/01/202/</id>
    <published>2016-12-01T15:48:04.000Z</published>
    <updated>2016-12-06T14:22:21.638Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/t2.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><p>由于泛型T不确定是值类型还是引用类型，所以<br><code>T a = null</code>这句是错误的（值类型就空了）。</p>
<p><code>T a = default(null)</code>这样的话值类型就是0，引用类型就是null</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>这个一般是yield return, yield break联合使用；如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; SName(<span class="keyword">int</span> a)</div><div class="line">&#123;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">    yield <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//注意返回值必须是 IEnumerable 或 IEnumerator</span></div><div class="line"><span class="comment">//好像说这种方法比在函数里面push或add更有效</span></div></pre></td></tr></table></figure></p>
<h4 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h4><p>这个我不是很深，以后补充；先看段代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class MyBase&lt;T&gt;</div><div class="line">    where T: class</div><div class="line">    , new() &#123;</div><div class="line">    public MyBase() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public MyBase(int n)</div><div class="line">        :this() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public virtual T ShowD() &#123;</div><div class="line">        Console.WriteLine("MyBase");</div><div class="line">        T b = new T();//这里很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyDrive&lt;D&gt; : MyBase&lt;D&gt;, IEnumerable</div><div class="line">    where D: class, new() &#123;</div><div class="line">    public MyDrive()</div><div class="line">        : base(3) &#123;</div><div class="line">        Console.WriteLine("Drive");</div><div class="line">    &#125;</div><div class="line">    public MyDrive(int a)</div><div class="line">    &#123; &#125;</div><div class="line">    public override D ShowD() &#123;</div><div class="line">        Console.WriteLine("MyDrive");</div><div class="line">        D b = new D();//这句很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyDrive&lt;Program&gt; my = new MyDrive&lt;Program&gt;(3);//调用</div></pre></td></tr></table></figure></p>
<p>第一个类；where对T约束为引用类型（值类型可以用struct），这样调用<code>&lt;&gt;</code>里面就只能是引用类型了<br>除此外where还约束为new()，表示<code>&lt;&gt;</code>里的类型必须有默认的构造函数，这样才可以用<code>new T()</code>这样的代码（测试发现里面不能加参数）</p>
<p>where还可以准确约束，有点像c++的模板特例化</p>
<h4 id="协变和抗变"><a href="#协变和抗变" class="headerlink" title="协变和抗变"></a>协变和抗变</h4><p><a href="http://blog.csdn.net/sudazf/article/details/17148971" target="_blank" rel="external">http://blog.csdn.net/sudazf/article/details/17148971</a></p>
<h4 id="可空类型及运算符"><a href="#可空类型及运算符" class="headerlink" title="可空类型及运算符"></a>可空类型及运算符</h4><p>可空类型原型是<code>System.Nullable&lt;T&gt;</code>，简单型<code>T?</code><br>网上说它是为了sql设计<br>操作符可以和原型相同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//？？是判断是否为空</span></div><div class="line"><span class="keyword">int</span>? x = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> y = x ?? <span class="number">5</span>;<span class="comment">//y:3</span></div><div class="line"></div><div class="line">x = <span class="number">0</span>;</div><div class="line">y = x ?? <span class="number">6</span>;<span class="comment">//x:0 y:0</span></div><div class="line"></div><div class="line">x = null;</div><div class="line">y = x ?? <span class="number">7</span>;<span class="comment">//x:null y:7</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//再看运算符应用（好像它只能用于引用类型，不能用于值类型）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DoQG</span><span class="params">(dynamic dy)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">string</span> result = dy.GG();</div><div class="line">    <span class="keyword">return</span> result ?? <span class="string">"hehe"</span>;</div><div class="line">&#125;</div><div class="line">MyClass hh = <span class="keyword">new</span> MyClass();</div><div class="line">YouClass yy = <span class="keyword">new</span> YouClass();</div><div class="line">MyClass sss = yy ?? null;</div></pre></td></tr></table></figure></p>
<h4 id="各个泛型容器及性能"><a href="#各个泛型容器及性能" class="headerlink" title="各个泛型容器及性能"></a>各个泛型容器及性能</h4><p>队列Queue<t><br>栈Statck<t><br>链表LinkedList<t><br>有序列表SortedList<tkey, tvalue="">, IComparef<tkey>接口用于排序<br>字典Dictionary<tkey, tvalue=""> 无排序 键类型需要实现GethashCode和IEquatable<t><br>有序字典SortedDictionary<tkey, tvalue=""><br>集 HashSet<t><br>有序集 SortedSet<t></t></t></tkey,></t></tkey,></tkey></tkey,></t></t></t></p>
<p>书上本来是有个性能表，但是纠结了感觉没啥用，就不写等以后更新。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> internal IMyInter&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂时看它和虚基类没啥区别呀！！！！！！以后再加吧。</p>
<h4 id="foreach的自定义"><a href="#foreach的自定义" class="headerlink" title="foreach的自定义"></a>foreach的自定义</h4><p>自定义类要使用foreach，就必须实现IEnumerator和IEnumerable<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDrive : IEnumerable</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span><span class="params">()</span></span></div><div class="line">    &#123; <span class="keyword">return</span> <span class="keyword">new</span> MyTor(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> MyTor : IEnumerator</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="keyword">public</span> object Current &#123; get &#123; <span class="keyword">return</span> null; &#125; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">MyDrive ss = <span class="keyword">new</span> MyDrive();</div><div class="line">foreach (var t in ss) &#123;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="排序搜索等"><a href="#排序搜索等" class="headerlink" title="排序搜索等"></a>排序搜索等</h4><p>本以为较简单的，看了下发现和其它还有关，就记录了。<br>两种：<br>IComparable在要比较的对象类中实现，可以比较该对象和另一对象<br>IComparer在一个单独的类中实现，可以比较任意俩个对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person : IComparable</div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span> <span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        Name = s;</div><div class="line">        Age = i;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span><span class="params">(object obj)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (obj is Person)</div><div class="line">        &#123;</div><div class="line">            Person ot = obj as Person;</div><div class="line">            <span class="keyword">return</span> ot.Age - <span class="keyword">this</span>.Age;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> PersonCompareName : IComparer</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Compare</span><span class="params">(object x, object y)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (x is Person &amp;&amp; y is Person)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> Comparer.Default.Compare(</div><div class="line">                ((Person)x).Name,</div><div class="line">                ((Person)y).Name);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></div><div class="line">&#123;</div><div class="line">    List&lt;Person&gt; asa = <span class="keyword">new</span> List&lt;Person&gt;();</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam1"</span>, <span class="number">1</span>));</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam2"</span>, <span class="number">2</span>));</div><div class="line">    asa.Add(<span class="keyword">new</span> Person(<span class="string">"nam3"</span>, <span class="number">3</span>));</div><div class="line"></div><div class="line">    asa.Sort();<span class="comment">//排序会进行比较，这个比较会调用IComparable的CompareTo</span></div><div class="line"></div><div class="line">    PersonCompareName ii = <span class="keyword">new</span> PersonCompareName();</div><div class="line">    asa.Sort(ii.Compare);<span class="comment">//这个排序比较会调用IComparer的Compare</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="其它接口"><a href="#其它接口" class="headerlink" title="其它接口"></a>其它接口</h5><ul>
<li><p>搜索<br>如同排序，搜索本身是Predicate<t>继承，传入的话直接一个static函数就好了。<br>搜索可以返回数组</t></p>
</li>
<li><p>字典<br>Dictionary<k, v="">，这个字典缺点就是添加的键值不能相同，同了就抛出异常。<br>所以每次add要判断是否存在，感觉好麻烦！</k,></p>
</li>
</ul>
<p><strong>添加元素</strong> AddRange()，IEnumerable<t><br><strong>删除元素</strong> RemoveAt，IEquatable<t>接口<br><strong>搜索元素</strong> IndexOf、LastIndexOf()、FindIndex()、FindLastIndex()、Find()、FindLast()，IEquatable<t>接口<br><strong>排序元素</strong> Sort()、Comparison<t>和IComparer<t>前面已讲</t></t></t></t></t></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>c#空字符和无字符201</title>
    <link href="https://xuecat.github.io/2016/12/01/201/"/>
    <id>https://xuecat.github.io/2016/12/01/201/</id>
    <published>2016-12-01T13:24:56.000Z</published>
    <updated>2016-12-01T13:26:51.130Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> str1=stirng.Empty;</div><div class="line"><span class="built_in">string</span> str2=<span class="string">""</span>;</div><div class="line"><span class="built_in">string</span> str3=null;</div></pre></td></tr></table></figure>
<p>str1和str2暂时可视为无区别，但建议多str1<br>str3是空指针，堆上没有开辟内存的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>windbg调试200</title>
    <link href="https://xuecat.github.io/2016/12/01/200/"/>
    <id>https://xuecat.github.io/2016/12/01/200/</id>
    <published>2016-12-01T13:05:20.000Z</published>
    <updated>2017-01-21T08:56:01.846Z</updated>
    
    <content type="html"><![CDATA[<p>64位寻址到16EB （1EB=1000TB）x64控制寻址范围16TB</p>
<p>ps: 退出指令 <code>q</code> 就好了。</p>
<p>dump：<a href="https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump" target="_blank" rel="external">https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump</a></p>
<p>如果只想程序运行时的内存dump，直接从资源管理器；进程tab页上，选中程序右键，就有个产生dump选项。</p>
<p>debug工具一般都有debugger.chm这个文档可以参考<br><strong>x64</strong>:</p>
<ol>
<li>拖拽到windbg，lm查看模块状态</li>
<li>查看时间戳(lmt)，找到对应pdb，设置pdb路径</li>
<li>重新加载pdb(.reload)，运行分析命令(!analyze -v)<br>一般崩溃会有exception，就查找这个字符串，就可以找到对应执行函数。(~N 切换到N号线程，主线程是0号)<br>主线程没有就切换到其它线程查找(~*e kb)</li>
</ol>
<p><strong>x32</strong>:<br>基本相同，但是当32位程序运行在64位系统的时候，产生的dump</p>
<ol>
<li>先加载64位的扩展(.load wow64exts)</li>
<li>切换到32位模式(!sw)</li>
<li>然后才再像上面那样调试</li>
</ol>
<hr>
<p>今天又测试了下，指定符号、源、exe后，lm居然没找到对应符号。。。</p>
<p>只好强制加载了。<br><strong>后来发现居然要多个后缀才行</strong>：<br><code>.reload /i simpledoc1.exe</code>这样才行。。。</p>
<p><strong>lm会全部显示，太多了，如果只想显示能加载符号的模块的话用：</strong><code>lml</code>就可以了</p>
<h3 id="栈破坏第一个例子"><a href="#栈破坏第一个例子" class="headerlink" title="栈破坏第一个例子"></a>栈破坏第一个例子</h3><hr>
<p>今天认真看了调试的第一个例子，做下记录，调试的是一个内存破坏的例子：<br>1、先用<code>k</code>命令来显示异常前的函数执行堆栈（后面跟个数字就表示显示几行， k 3：显示最后三行）</p>
<blockquote>
<p>我喜欢用<code>kpn</code>。因为<code>p</code>会列举出函数的调用参数；<code>n</code>会对他们排号，这样方便我用<code>frame</code>来切换上下文作用域；（另外说下<code>b</code>会列举参数地址，反正我也不咋习惯看，就不用）</p>
</blockquote>
<p>2、找到我方代码函数后，用<code>.frame &lt;number&gt;</code>的形式切换到函数的上下文里面。（这个 number 就是我上面说的<code>n</code>所列出的排号）</p>
<blockquote>
<p>为何要切换呢？因为我要找变量呀！！ 默认的<code>X</code>找的是全局变量，我要找局部变量就只好切进函数里去。<br>X Mytest!g<em>* //在Mytest模块中找 g</em> 开头的变量<br>切进去，我直接 X g_ 就可以找到</p>
</blockquote>
<p>3、 X指令或dv，找出变量。</p>
<blockquote>
<p>我喜欢<code>X</code>，虽然都差不多。找的的变量会自动给出此变量的地址</p>
</blockquote>
<p>4、dt转换</p>
<blockquote>
<p>拿到变量地址后，就 <code>dt CAppInfo 0x0047d768</code> 它会把此地址转换成设置的类型，并变量的成员内存一一的列举出来。<br>简单来说这就是个c式的强制转换，只是为了方便研究成员变量的有效性</p>
</blockquote>
<p>5、dd查看成员变量内存</p>
<blockquote>
<p>如上面所说，成员变量被全部列出来了，就可以一个一个查看成员变量的内存<code>dd 0x72726f43</code>。这样就判断有效和无效！</p>
</blockquote>
<hr>
<h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>bp ConsoleApplication1!main+4c 函数第4行<br>bp ConsoleApplication1.cpp:4<br>t 运行单步</p>
<h3 id="k命令"><a href="#k命令" class="headerlink" title="k命令"></a>k命令</h3><p>kb 显示的参数 从左到右分别为 ebp， ret ，arg1， arg2</p>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>r eip  查看下一指令地址<br>u eip  查看下一指令的汇编代码</p>
<h3 id="约定不一致"><a href="#约定不一致" class="headerlink" title="约定不一致"></a>约定不一致</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(<span class="number">__</span>cdecl *MYPROC)</span><span class="params">(DWORD dwOne, DWORD dwTwo)</span></span>;</div><div class="line"><span class="function">VOID <span class="title">CallProc</span><span class="params">(MYPROC pProc)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> <span class="number">__</span><span class="function">cdecl <span class="title">wmain</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    HMODULE hMod = LoadLibrary(<span class="string">L"Win32Dll.dll"</span>);</div><div class="line">    <span class="keyword">if</span> (hMod)</div><div class="line">    &#123;</div><div class="line">        MYPROC pProc = (MYPROC)GetProcAddress(hMod, <span class="string">"InitModule"</span>);</div><div class="line">        <span class="keyword">if</span> (pProc)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//这里InitModule本阿里是个__stadcall的约定，由于获取时用 __cdecl。导致函数返回前就清理了栈，使得堆栈破坏。</span></div></pre></td></tr></table></figure>
<h3 id="自动错误"><a href="#自动错误" class="headerlink" title="自动错误"></a>自动错误</h3><p>以前把程序放入windbg，指定pdb，然后运行。如果有空指针调用它会自动跳转到代码。<br>后来有几次测试，又不成功了。<br>今天我无意中发现，<code>.frame &lt;number&gt;</code>到错误的函数后，它又能自动加载跳转到代码了。</p>
<h3 id="堆错误-使用未初始化状态"><a href="#堆错误-使用未初始化状态" class="headerlink" title="堆错误-使用未初始化状态"></a>堆错误-使用未初始化状态</h3><p>此类报错，会在加载后，给出问题代码的，如果有pdb则会直接指出源代码。先看windbg显示的：<br>ConsoleApplication1!wmain+0x87:<br>00265107 c7000a000000    mov     dword ptr [eax],0Ah  ds:002b:baadf00d=????????</p>
<p>eax 的值是baadfood 填充模式时分配成功但没初始化。释放填充是feeefeee</p>
<h3 id="堆错误-堆句柄不匹配"><a href="#堆错误-堆句柄不匹配" class="headerlink" title="堆错误-堆句柄不匹配"></a>堆错误-堆句柄不匹配</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hSmallHeap = GetProcessHeap();<span class="comment">//默认堆</span></div><div class="line">hLargeHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//私有堆</span></div><div class="line"></div><div class="line">_DPH_BLOCK_INFORMATION有个Heap会辨识堆句柄，以此来判断堆句柄是否匹配。</div></pre></td></tr></table></figure>
<p>去找结构体，自己声明，还要自己定义（因为它定义了才会有符号，才能找到自己声明的那个结构体）</p>
<h3 id="死锁情况"><a href="#死锁情况" class="headerlink" title="死锁情况"></a>死锁情况</h3><p><code>~*kb</code> 显示真进线程信息很有用 (<code>~*</code>切线程)</p>
<p>先看它们第一行信息，Unfrozen表示它们都在运行。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>  <span class="string">Id:</span> <span class="number">2384.</span>f68 <span class="string">Suspend:</span> <span class="number">1</span> <span class="string">Teb:</span> <span class="number">7</span>efdd000 Unfrozen<span class="comment">//主进程</span></div><div class="line"><span class="number">1</span>  <span class="string">Id:</span> <span class="number">2384.14</span>f4 <span class="string">Suspend:</span> <span class="number">1</span> <span class="string">Teb:</span> <span class="number">7</span>efda000 Unfrozen<span class="comment">//子线程</span></div><div class="line"><span class="comment">//这个id很有用，特别是小数点后面的数字代表EBP。</span></div><div class="line"><span class="comment">//后面的OwningThread上的值就是此数字。</span></div></pre></td></tr></table></figure></p>
<p>从堆栈看，俩个线程都在<code>NtWaitForSingleObject</code>结束。找到执行函数<code>RtlEnterCriticalSection</code>的参数<br>在分别<code>!cs 00d9a138</code> <code>!cs 00d9a150</code>(这个命令由于涉及到了内核对象，必须去服务器那边下符号)<br>发现这俩个临界区都锁住了，<code>LOCKED LockCount = 0x1 WaiterWoken = No</code>；<br>而它们的<code>OwningThread</code>则正好分别是彼此，说明是互相锁住了。</p>
<h3 id="锁中产生异常"><a href="#锁中产生异常" class="headerlink" title="锁中产生异常"></a>锁中产生异常</h3><p>临界区的<code>OwningThread</code>会被分配给一个找不到ID的地址（Windows异常模块接管），会导致接下来不会释放临界区。<br>且问题栈会有：<code>DbgBreakPoint DbgUiRemoteBreakin</code></p>
<p>微软建议，封装个类，在析构函数进行解锁。（所以建议使用CCriticalSection而不是windows对象）</p>
<h3 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h3><p>当主线程结束工作者线程是，工作者线程正处于分配内存或释放内存的过程中。<br>在这些操作中，堆管理器通常会获得一个临界区。<br>当工作者线程被强行结束时，堆管理器将永远无法离开临界区。<br>意思就是说你terminal时正在开辟堆时（new），可能会导致堆管理器死锁。</p>
<h3 id="DllMain的死锁问题"><a href="#DllMain的死锁问题" class="headerlink" title="DllMain的死锁问题"></a>DllMain的死锁问题</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">BOOL</span> WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">BOOL</span> bRet=<span class="literal">FALSE</span>;</div><div class="line">    <span class="keyword">switch</span>(fdwReason)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</div><div class="line">        &#123;</div><div class="line">            DWORD dwId=<span class="number">0</span>;</div><div class="line">            HANDLE hThread=<span class="literal">NULL</span>;</div><div class="line"></div><div class="line">            hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, InitDllProc, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwId);        </div><div class="line">            <span class="keyword">if</span>(hThread)</div><div class="line">            &#123;</div><div class="line">                WaitForSingleObject(hThread, INFINITE);</div><div class="line">                CloseHandle(hThread);</div><div class="line">                bRet=<span class="literal">TRUE</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bRet;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如上此代码会陷入卡死状态。</span></div></pre></td></tr></table></figure>
<ol>
<li><p>进入dllmain后创建线程。</p>
<blockquote>
<p>当windows创建线程时，线程并不会自动从<code>kernel32!BaseThreadStart</code>开始执行；<br>而是首先由APC分发器分发一个APC到新线程，然后作为apc进行初始化完成后才会执行线程。<br>然而APC的分发有一个加载器锁来控制的，以此保护分发访问的冲突问题。<br><strong>然而对于DllMain来说，它本身就是动态库的加载和创建也会出现新线程进程，它本身也会用到APC管理器</strong><br>ps：apc分发和回收用的是同一个锁</p>
</blockquote>
</li>
<li><p>dllmain等待线程</p>
<blockquote>
<p>dllmain等待子线程的创建和设置事件。<br>然而子线程等待dllmain的APC管理器锁解锁。<br>如此就造成了死锁的情况。<br>apc的死锁导致调试线程的注入发生中断，超过30秒后；调试线程会自动挂起进程中所有线程。</p>
</blockquote>
</li>
</ol>
<h3 id="临界区的判断"><a href="#临界区的判断" class="headerlink" title="临界区的判断"></a>临界区的判断</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span>x000 DebugInfo        : 0<span class="type">x0085c560</span> _RTL_CRITICAL_SECTION_DEBUG</div><div class="line">+<span class="number">0</span>x004 LockCount        : 0<span class="type">n</span>-<span class="number">1</span></div><div class="line">+<span class="number">0</span>x008 RecursionCount   : 0<span class="type">n0</span></div><div class="line">+<span class="number">0</span>x00c OwningThread     : (<span class="keyword"><span class="keyword">null</span></span>) </div><div class="line">+<span class="number">0</span>x010 LockSemaphore    : (<span class="keyword"><span class="keyword">null</span></span>) </div><div class="line">+<span class="number">0</span>x014 SpinCount        : 0<span class="type">xfa0</span></div></pre></td></tr></table></figure>
<p><code>dt CRITICAL_SECTION</code>和<code>!cs</code>都行。<br>当处理一个尚未被初始化的临界区，看的值都是随机的<br>当被删除的临界区，看到的值是零<br>过度释放的临界区，会导致程序挂起，<code>LockCount &lt; -1 || RscursionCount &lt; 0</code></p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>64位运行32位时，加载WOW（windows on windows）子系统模块</p>
<p>Mini dump代码直接实例初始化处调用RunCrashHandler<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDumpFile</span><span class="params">(LPCTSTR lpstrDumpFilePathName, EXCEPTION_POINTERS *pException)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 创建Dump文件    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	HANDLE hDumpFile = CreateFile(lpstrDumpFilePathName, GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Dump信息    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	MINIDUMP_EXCEPTION_INFORMATION dumpInfo;</div><div class="line">	dumpInfo.ExceptionPointers = pException;</div><div class="line">	dumpInfo.ThreadId = GetCurrentThreadId();</div><div class="line">	dumpInfo.ClientPointers = TRUE;</div><div class="line"></div><div class="line">	<span class="comment">// 写入Dump文件内容    </span></div><div class="line">	<span class="comment">//    </span></div><div class="line">	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hDumpFile, MiniDumpNormal, &amp;dumpInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">	CloseHandle(hDumpFile);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">LONG WINAPI <span class="title">UnhandledExceptionFilterEx</span><span class="params">(<span class="keyword">struct</span> <span class="number">_</span>EXCEPTION_POINTERS *pException)</span></span></div><div class="line">&#123;</div><div class="line">	TCHAR szMbsFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	::GetModuleFileName(<span class="literal">NULL</span>, szMbsFile, MAX_PATH);</div><div class="line">	TCHAR* pFind = <span class="number">_</span>tcsrchr(szMbsFile, <span class="number">_</span>T(<span class="string">'\\'</span>));</div><div class="line">	<span class="keyword">if</span> (pFind)</div><div class="line">	&#123;</div><div class="line">		*(pFind + <span class="number">1</span>) = <span class="number">0</span>;</div><div class="line">		SYSTEMTIME Time = &#123; <span class="number">0</span> &#125;;</div><div class="line">		TCHAR szGuid[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">		GUID guid;</div><div class="line">		<span class="keyword">if</span> (S_OK == ::CoCreateGuid(&amp;guid))</div><div class="line">		&#123;</div><div class="line">			<span class="number">_</span>sntprintf_s(szGuid, <span class="keyword">sizeof</span>(szGuid),</div><div class="line">				<span class="number">_</span>T(<span class="string">"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X.dmp"</span>),</div><div class="line">				guid.Data1, guid.Data2, guid.Data3,</div><div class="line">				guid.Data4[<span class="number">0</span>], guid.Data4[<span class="number">1</span>],</div><div class="line">				guid.Data4[<span class="number">2</span>], guid.Data4[<span class="number">3</span>],</div><div class="line">				guid.Data4[<span class="number">4</span>], guid.Data4[<span class="number">5</span>],</div><div class="line">				guid.Data4[<span class="number">6</span>], guid.Data4[<span class="number">7</span>]);</div><div class="line">		&#125;</div><div class="line">		<span class="number">_</span>tcscat_s(szMbsFile, MAX_PATH, szGuid );</div><div class="line">		CreateDumpFile(szMbsFile, pException);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// <span class="doctag">TODO:</span> MiniDumpWriteDump  </span></div><div class="line">	FatalAppExit(<span class="number">-1</span>, <span class="number">_</span>T(<span class="string">"Fatal Error"</span>));</div><div class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunCrashHandler</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	SetUnhandledExceptionFilter(UnhandledExceptionFilterEx);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;64位寻址到16EB （1EB=1000TB）x64控制寻址范围16TB&lt;/p&gt;
&lt;p&gt;ps: 退出指令 &lt;code&gt;q&lt;/code&gt; 就好了。&lt;/p&gt;
&lt;p&gt;dump：&lt;a href=&quot;https://social.technet.microsoft.com/Forums
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>VA_snippets199</title>
    <link href="https://xuecat.github.io/2016/11/29/199/"/>
    <id>https://xuecat.github.io/2016/11/29/199/</id>
    <published>2016-11-29T15:17:33.000Z</published>
    <updated>2016-11-29T16:03:05.058Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">Aline</div><div class="line">//////////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">big moudle</div><div class="line">/************************************************************************/</div><div class="line">/* $end$                                                                     */</div><div class="line">/************************************************************************/</div><div class="line"></div><div class="line">brief</div><div class="line">/*</div><div class="line"> * @brief $end$</div><div class="line"> */</div><div class="line"></div><div class="line">enum</div><div class="line"> /**&lt; $end$ */</div><div class="line"></div><div class="line">member</div><div class="line"> /**&lt; @brief $end$,  */</div><div class="line"></div><div class="line"> function</div><div class="line"> /** </div><div class="line"> * @param [in]</div><div class="line"> * @param [out]</div><div class="line"> * @return</div><div class="line"> * @brief $end$</div><div class="line"> * @note</div><div class="line"> */</div><div class="line"></div><div class="line"> Time</div><div class="line"> // $end$ [$MONTH$/$DAY$/$YEAR$ %USERNAME%]</div><div class="line"></div><div class="line">Doxygen - Class Comment</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Class Comment (Long)</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> * @ingroup GroupName</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note </div><div class="line"> * @author %USERNAME%</div><div class="line"> * @version 1.0</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"> Doxygen - Header Comment</div><div class="line"> /*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> *</div><div class="line"> * $end$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Header Comment (Long)</div><div class="line">/*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> * @date $DATE$ $HOUR$:$MINUTE$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note</div><div class="line">*/</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>多线程198</title>
    <link href="https://xuecat.github.io/2016/11/21/198/"/>
    <id>https://xuecat.github.io/2016/11/21/198/</id>
    <published>2016-11-21T15:22:33.000Z</published>
    <updated>2016-11-26T07:16:03.812Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/t1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>咋说呢，一直以来虽然知道<code>_beginthreadex</code>比较好。但是想起55用<code>CreateThread</code>，还是有点余悸。</p>
<p><strong>先看段原话</strong>：</p>
<p>有些CRT的函数象<code>malloc(), fopen(), _open(), strtok(), ctime(), 或localtime()</code>等函数需要专门的线程局部存储的数据块，<br>这个数据块通常需要在创建线程的时候就建立，如果使用<code>CreateThread</code>，这个数据块就没有建立，然后会怎样呢？<br>在这样的线程中还是可以使用这些函数而且没有出错，实际上函数发现这个数据块的指针为空时，会自己建立一个，<br>然后将其与线程联系在一起，这意味着如果你用<code>CreateThread</code>来创建线程，然后使用这样的函数，<br>会有一块内存在不知不觉中创建，遗憾的是，这些函数并不将其删除，而<code>CreateThread</code>和<code>ExitThread</code>也无法知道这件事，<br>于是就会有Memory Leak，在线程频繁启动的软件中(比如某些服务器软件)，迟早会让系统的内存资源耗尽！<br></p>
<hr>
<p><strong>说白了</strong>：如果多线程里面有CRT函数，最好使用<code>_beginthread</code>   <code>_beginthreadex</code>   <code>AfxBeginThread</code>(这个函数内部调用<code>_beginthreadex</code>创建处理的<code>CWinThread</code>专门的UI线程，可以通过发送接收message)</p>
<p>上面四个线程都有相应的<code>ExitThread或_endthread</code>；当然这些函数必须放入线程函数中。<br></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><h4 id="共同的毛病1："><a href="#共同的毛病1：" class="headerlink" title="共同的毛病1："></a>共同的毛病1：</h4><p><strong>虽然</strong>：在线程被创建成功后，都可以用<code>WaitForSingleObject( hThread, INFINITE );</code>来等待线程结束。<br><strong>但是这是不准的</strong>：一些<code>begin</code>函数本身就有<code>CloseHandle</code>了（如：<code>_beginthread</code>），再加上一些代码的<code>CloseHandle</code>，<br>所以无法正确知道线程的计数到底是在哪个时候被置为0，而且被置为0也不一定会是线程退出。<br>再说执行完线程函数后，<code>beging</code>函数本身有许多代码要执行。<br><strong>也就是说，最好不要这么等待线程结束，最好给个事件、原子等放在线程函数末尾，来判断线程是否结束。</strong></p>
<h4 id="共同的毛病2："><a href="#共同的毛病2：" class="headerlink" title="共同的毛病2："></a>共同的毛病2：</h4><p>如果在线程函数中调用退出函数，是会立即退出的。<br>也就是说连执行线程函数中，定义类的析构函数都来不及，就会直接退出线程返回，<br>如果那个类有析构有内存释放的话就糟糕了，会出现内存泄漏的。<br><strong>也就是说，最好不要用退出线程函数来退出线程，用return自然返回是最好的。</strong></p>
<h4 id="内存释放："><a href="#内存释放：" class="headerlink" title="内存释放："></a>内存释放：</h4><ul>
<li>内存释放这里也有个共同点； 创建线程后直接<code>CloseHandle</code>是可以的，这样的线程对象，在函数运行完了就自动释放（就算是_beginthread等有自释放代码的类型也同样适用）</li>
</ul>
<p><code>AfxBeginThread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthreadex</code>必须手动<code>CloseHandle</code><br><code>CreateThread</code>必须手动<code>CloseHandle</code></p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p><code>AfxBeginThread</code>创建的线程比较庞大，一般的后台运行线程是没必要的<br><code>CreateThread</code>创建的线程无法使用CRT函数<br><code>_beginthread</code>创建的线程可以使用CRT函数，但引用官方的话来说：“使用 _beginthreadex 比 _beginthread 更为安全”；</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="c函数" scheme="https://xuecat.github.io/tags/c%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="多线程" scheme="https://xuecat.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>c#入门经典(1)197</title>
    <link href="https://xuecat.github.io/2016/11/21/197/"/>
    <id>https://xuecat.github.io/2016/11/21/197/</id>
    <published>2016-11-21T13:39:27.000Z</published>
    <updated>2017-01-09T13:58:11.745Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/r4.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>唉！！，es6正看着呢；去海外组了。。。。要补c#知识了</p>
<h3 id="NET程序："><a href="#NET程序：" class="headerlink" title=".NET程序："></a>.NET程序：</h3><p>使用.NET兼容语言（如c#）编写程序 -&gt; 把代码编译为CIL，存储在程序集中（即VS干的事） <br><br>-&gt; 执行时，先使用JIT编译器将代码编译为本机代码 -&gt; 在托管的CLR环境下运行本机代码。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h4><p>字节数增多：sbyte(1) short(2) int(4) long(8)<br>不同的是：其它类型的<code>unsigned</code>前面加<code>u</code>就好，唯独<code>byte</code>是0到255</p>
<p>转义字符(\”表示”)和字面量(100L 100F)都和c++差不多<br>多了个新功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> strTest = <span class="string">"wangqiu"</span>;</div><div class="line"><span class="built_in">string</span> strHEHE = $<span class="string">"&#123;strTest&#125; hehe"</span> + $<span class="string">" &#123;3+5&#125;de"</span>;<span class="comment">//这样是可以的哟，用法如同js的模板字符</span></div></pre></td></tr></table></figure>
<p><strong>差点忘了说，c#中变量类型其实全是System的类，也就意味着基本变量类型本身就有很多成员函数可以使用</strong></p>
<h4 id="typeof和GetType"><a href="#typeof和GetType" class="headerlink" title="typeof和GetType"></a>typeof和GetType</h4><p>c++的是typeid，记得mfc好像有个，忘了。</p>
<p>都返回<code>System.Type</code>类型，一个是类函数一个是语言函数（参数是类名）。</p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><code>switch</code>语句有点不同，多了个<code>goto case &lt;com&gt;:</code>，用来实现在这个case语句中跳转到其它case语句中</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>用法基本同；c#多了层保险，可以用<code>checked((type))</code>出现的崩溃来保证，高字节向低字节转换;也可以默认设置强制转换加check；在书67页。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>用法和c++基本同；多了个指定类型，<code>enum Type : long</code>，这样指定枚举变量的类型。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//很智能，可以自动创建数组类，这样就能使用很多成员函数了。</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">6</span>, <span class="number">7</span>&#125;;<span class="comment">//new int[number],不能new int;</span></div><div class="line"></div><div class="line"><span class="comment">//数组是引用类型，开辟的元素也在堆上</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</div><div class="line">var inlist = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</div></pre></td></tr></table></figure>
<p>数组的遍历可以用<code>for</code>也可以用<code>foreach(string f in fN)</code>;只是<code>foreach</code>里的f是只读属性，不能写。</p>
<ul>
<li>多元数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//几元数组就用几个`,`表示</span></div><div class="line"><span class="keyword">int</span>[,] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">int</span>[,] s = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;<span class="comment">//但是这种赋值会改变，声明的几元</span></div><div class="line"><span class="comment">//foreach会一行一行遍历全部元素。</span></div></pre></td></tr></table></figure>
<ul>
<li>锯齿数组<br>这个更该是数组中的数组，一个行不一定固定个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [][] d = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>&#125;,<span class="comment">//这行就一个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,<span class="comment">//这行俩个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">8</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>数组是合并相同类型，元祖就是合并不同类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; tuple = Tuple.Create&lt;<span class="keyword">int</span> , <span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3.3</span>);</div></pre></td></tr></table></figure></p>
<p>暂时我认为这个东西没啥用，不如用结构体。看以后吧!</p>
<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p><code>var</code>会自动转换到相应的类型，当然也可以访问相应的成员函数。</p>
<h4 id="nameof"><a href="#nameof" class="headerlink" title="nameof"></a>nameof</h4><p>把变量名变成字符形式</p>
<h4 id="as和is"><a href="#as和is" class="headerlink" title="as和is"></a>as和is</h4><p>is会做俩次检查，as会做一次检查，as效率会高点<br>as类似于强制转换，转换失败便返回null<br>as只能用于引用类型和装箱转换，所以值类型还是得用is。除此外as还有隐式转换（见类的隐式显示）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MyDrive bs = <span class="keyword">new</span> MyDrive();</div><div class="line">Program pro = bs as Program;</div><div class="line"><span class="keyword">if</span> (pro) &#123;&#125;<span class="comment">//这种写法大误，被c++惯坏了。</span></div><div class="line"><span class="keyword">if</span> (pro != null)<span class="comment">//才行。如果要上面写法成功的话就必须加个隐式转换的bool</span></div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="参数调用顺序是从左向右"><a href="#参数调用顺序是从左向右" class="headerlink" title="参数调用顺序是从左向右"></a>参数调用顺序是从左向右</h4><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>类中函数默认是private类型的，如果访问要public<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数组参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">int</span>[] intA</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//引用参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> val</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">ref</span> intA);<span class="comment">//它调用也比较特殊，还有就是intA必须要被赋过值</span></div><div class="line"></div><div class="line"><span class="comment">//输出参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> valA</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">out</span> intA)<span class="comment">//感觉它比引用都高级</span></div></pre></td></tr></table></figure></p>
<p>函数可以重载，但是<code>out</code>和<code>ref</code>不能相同</p>
<h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetI</span><span class="params">()</span> </span>=&gt; <span class="number">1</span> + <span class="number">3</span>;</div><div class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">string</span> , <span class="keyword">int</span>&gt; hh = (<span class="comment">/*string */</span>x, <span class="comment">/*string */</span>y) =&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ol>
<li>支持默认参数，同时不会在意默认参数位置（即不像c++那样默认参数必须放后面）</li>
<li>支持无序传入，<code>SName(kk:1, hh:2)</code>这种形式传入是支持的，但是如果这样写就必须把所有参数写完。</li>
</ol>
<h4 id="c-的委托和事件"><a href="#c-的委托和事件" class="headerlink" title="c#的委托和事件"></a>c#的委托和事件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;&#125;</div><div class="line"><span class="function">delegate <span class="keyword">double</span> <span class="title">Process</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span>;</div><div class="line">Process tp1 = Run;</div><div class="line">Process tp2 = (<span class="keyword">int</span> p1, <span class="keyword">int</span> p2) =&gt; &#123;<span class="keyword">return</span> p1 + p2;&#125;;</div><div class="line">Process tp3 = <span class="keyword">new</span> Process(Run);<span class="comment">//标准建议这种写法，说是能明白干了什么</span></div><div class="line"></div><div class="line"><span class="function">delegate <span class="keyword">int</span> <span class="title">NumberChanger</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</div><div class="line">NumberChanger nc1 = <span class="keyword">new</span> NumberChanger(AddNum);<span class="comment">//这样才对嘛，反正引用类型都是在堆里</span></div><div class="line">NumberChanger nc2 = <span class="keyword">new</span> NumberChanger(MultNum);<span class="comment">//</span></div><div class="line"></div><div class="line">NumberChanger[] has = <span class="keyword">new</span> NumberChanger[<span class="number">3</span>];<span class="comment">//代理数组</span></div></pre></td></tr></table></figure>
<p>delegate 至少0个参数，至多32个参数，可以无返回值，也可以指定返回值类型<br>泛型Action至少0个参数，至多16个参数，无返回值<br>泛型Func至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值，不可void(它最后一个参数才表示返回)<br>泛型Predicate有且只有一个参数，返回值固定为bool</p>
<p>后面的泛型较delegate的好处是，不用先声明再使用；可以直接使用。<br>它们都可以当参数传值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Book</span><span class="params">()</span> </span>&#123; Console.WriteLine(<span class="string">"我是提供书籍的"</span>);&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Book</span><span class="params">(<span class="built_in">string</span> BookName)</span> </span>&#123;&#125;</div><div class="line">Action BookAction = <span class="keyword">new</span> Action(Book);</div><div class="line">Action BookAction1 = <span class="keyword">new</span> Action&lt;<span class="built_in">string</span>&gt;(Book);</div><div class="line">BookAction();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Test&lt;T1, T2&gt;(Func&lt;T1, T2, <span class="keyword">int</span>&gt; func, T1 a, T2 b) &#123; <span class="keyword">return</span> func(a, b); &#125;</div><div class="line">Console.WriteLine(Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(Fun,<span class="number">100</span>,<span class="number">200</span>));</div></pre></td></tr></table></figure>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件的实现严格需要代理的配合；关键字<code>event</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">public class Mom //事件发布器</div><div class="line">&#123;</div><div class="line">    public event Action&lt;int&gt; Eat;//订阅函数模板，这个需要代理函数的支持。所以也可以用delegate等来代替</div><div class="line">    public void Cook()//发布函数</div><div class="line">    &#123; Eat(1); &#125;</div><div class="line">&#125;</div><div class="line">public class Dad//事件订阅器</div><div class="line">&#123;</div><div class="line">    public void DEat(int a)//订阅函数</div><div class="line">    &#123; Console.WriteLine(&quot;dad eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">public class Child//事件订阅器</div><div class="line">&#123;</div><div class="line">    public void CEat(int a)//订阅函数</div><div class="line">    &#123; Console.WriteLine(&quot;child eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Mom mom = new Mom();</div><div class="line">        Dad dad = new Dad();</div><div class="line">        Child ch = new Child();</div><div class="line"></div><div class="line">        mom.Eat += dad.DEat;//开始订阅</div><div class="line">        mom.Eat += ch.CEat;</div><div class="line"></div><div class="line">        mom.Cook();//开始发布，这样就会执行dad的DEat和ch的CEat函数。</div><div class="line"></div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//然而当传入信息更复杂时，可以如下。事件进阶版</div><div class="line">public class Food : EventArgs</div><div class="line">&#123;</div><div class="line">    private string message;</div><div class="line">    public Food()</div><div class="line">    &#123; message = &quot;wq&quot;; &#125;</div><div class="line"></div><div class="line">    public Food(string ss)</div><div class="line">    &#123; message = ss; &#125;</div><div class="line">&#125;</div><div class="line">public class Mom</div><div class="line">&#123;</div><div class="line">    public event EventHandler&lt;Food&gt; Eat;</div><div class="line">    public void Cook()</div><div class="line">    &#123; Eat(this, new Food(&quot;hi&quot;)); &#125;</div><div class="line">&#125;</div><div class="line">public class Dad</div><div class="line">&#123;</div><div class="line">    public void DEat(object obj, Food fo)</div><div class="line">    &#123; Console.WriteLine(&quot;dad eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">public class Child</div><div class="line">&#123;</div><div class="line">    public void CEat(object obj, Food fo)</div><div class="line">    &#123; Console.WriteLine(&quot;child eat&quot;); &#125;</div><div class="line">&#125;</div><div class="line">class Program</div><div class="line">&#123;</div><div class="line">    static void Main(string[] args)</div><div class="line">    &#123;</div><div class="line">        Mom mom = new Mom();</div><div class="line">        Dad dad = new Dad();</div><div class="line">        Child ch = new Child();</div><div class="line"></div><div class="line">        mom.Eat += dad.DEat;</div><div class="line">        mom.Eat += ch.CEat;</div><div class="line"></div><div class="line">        mom.Cook();</div><div class="line"></div><div class="line">        Console.ReadKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ol>
<li><p>带运算；<br><code>Console.WriteLine($&quot;{SName(1, 2)}&quot;)</code>;会运算了SName函数再输出；注意的是它和参数传入形式不能共存。</p>
</li>
<li><p>参数传入；<br><code>Console.WriteLine(&quot;{0}a{1}&quot;, 10.02, 121);</code>这里<code>0</code>表示后面第一个参数，随着参数增加，可以依次递增。<br>还有，它会完整输出参数的形式。不用担心是string、int、float，它全按参数形式输出。</p>
</li>
<li><p>格式符；<br>只记录几个简单的：<br>D 十进制、N数字格式、X十六进制、P百分数格式；<br><code>Console.WriteLine(String.Format(&quot;{0:N1}&quot;, 10))</code>这里{0:N1}表示第一个参数，按数字格式输出，小数点后留一位。<br>格式符后面的数字可增加，表示小数点后面的位数。但是格式符前面不能加数字，实在加要用占位符。</p>
</li>
<li><p>占位符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">0194.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:###.##&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:####.#&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">194</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>零占位符：<br>如果格式化的值在格式字符串中出现“0”的位置有一个数字，则此数字被复制到结果字符串中。小数点前最左边的“0”的位置和小数点后最右边的“0”的位置确定总在结果字符串中出现的数字范围。<br>“00”说明符使得值被舍入到小数点前最近的数字，其中零位总被舍去。<br>数字占位符：<br>如果格式化的值在格式字符串中出现“#”的位置有一个数字，则此数字被复制到结果字符串中。否则，结果字符串中的此位置不存储任何值。<br>请注意，如果“0”不是有效数字，此说明符永不显示“0”字符，即使“0”是字符串中唯一的数字。如果“0”是所显示的数字中的有效数字，则显示“0”字符。<br>“##”格式字符串使得值被舍入到小数点前最近的数字，其中零总被舍去。</p>
<p>但是占位符又不简单的是这些：<code>(&quot;{0:123##2.00}&quot;, 11)</code>输出：123112.00 <code>(&quot;{0:123##20.00}&quot;, 11)</code>输出：123121.00<br>看来实际用还得再测试下。</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试信息的输出，这个调试信息是输出一行，比c++方便多了。<br><code>Debug.WriteLine()</code>只能在debug模式下<br><code>Trace.WriteLine()</code>任何模式下<br><code>Debug.Assert()</code><br><code>Trace.Assert()</code></p>
<p>也支持<code>try catch finally</code> finally必执行。</p>
<h4 id="XML文档"><a href="#XML文档" class="headerlink" title="XML文档"></a>XML文档</h4><p>这个我觉得很有必要。c++一般都是doxygen语法来，c#却这么高级直接官方支持（官方的snippets简直丧心病狂，太好用了）。<br>另外官方建议用<code>Sandcastle</code>来生成相关阅读文档。</p>
<p>值列举常用的，详细：<a href="http://www.cnblogs.com/mq0036/p/3544264.html" target="_blank" rel="external">http://www.cnblogs.com/mq0036/p/3544264.html</a><br>summary：永远描述类型<br>remarks：添加有关类型的信息，补充summary<br>param：参数描述<br>returns：返回值描述<br>value: 属性说明（官方示例是set、get的那些属性）<br>example：示例代码部分<br>c：文本标记为代码<br>code：多行指示为代码<br>exception：异常说明<br>see：seealso：用<code>&lt;see cref=&quot;member&quot;/&gt;</code></p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> #<span class="meta-keyword">undef</span> #<span class="meta-keyword">if</span> #<span class="meta-keyword">elif</span> #<span class="meta-keyword">else</span> #<span class="meta-keyword">endif</span> <span class="comment">//和c++相同</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG </span></div><div class="line">    <span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"Don't"</span><span class="comment">//c#的警告和错误的预编译和c++不同</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Wrong"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#region #endregion<span class="comment">//折叠用</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span><span class="comment">//此指令和c++使用完全不同</span></span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a>this和base</h4><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">internal <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//此关键字修饰的类，只运行同一个程序集访问（即同一exe或dll）</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//运行其它程序集访问</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//也可以加private等，此修饰符是抽象类，只能继承，不能实例化</span></div><div class="line"><span class="keyword">public</span> sealed <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//此修饰符不允许继承</span></div><div class="line"></div><div class="line"><span class="comment">//继承的时候要注意：编译器不允许派生类的可访性高于基类，即内部类继承公共类可以，公共类继承内部不行。</span></div><div class="line"><span class="comment">//以下不行：</span></div><div class="line">internal <span class="keyword">class</span> My&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MD : My&#123;&#125;<span class="comment">//不行</span></div><div class="line"></div><div class="line"><span class="comment">//继承时不能有多个基类，c#只运行一个基类；但是可以加接口的</span></div><div class="line"><span class="keyword">class</span> My : MyBass, IMyInterface, IMy&#123;&#125; <span class="comment">//虽然只能一个基类，但是多个接口是可以的。注意接口必须在基类后面</span></div></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>大量例子对属性的使用都是这样的，感觉这个属性有点多余。<br>属性支持访问控制：<code>get</code>和<code>set</code>支持使用：public、private、protected来控制访问。<br>属性支持重写：<code>abstract</code>、<code>virtual</code>、<code>override</code>这些可以联合使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="number">_</span>age;</div><div class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> Age &#123;</div><div class="line">    get &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">_</span>age;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span> &#123;</div><div class="line">        <span class="number">_</span>age = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自动属性<code>public double Height { get; set; }</code></p>
<h4 id="构造函数和析构"><a href="#构造函数和析构" class="headerlink" title="构造函数和析构"></a>构造函数和析构</h4><p>基本和c++相同，允许重载、访问控制。<br>不同：</p>
<ul>
<li>执行顺序（MyDericed继承基类）；MyDericed myO = new MyDericed();1、执行System.Object.Object()构造函数；2、执行MyBaseClass.MyBaseClass构造函数；3、执行MyDericed构造函数</li>
<li>委托不同；<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class MyD: MyBass</div><div class="line">&#123;</div><div class="line">    public MyD() : this(5, 6)&#123;&#125;//委托给自身的另一个构造函数</div><div class="line">    public MyD(int i, int j) : base(i) &#123;&#125;//调用基类构造函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="对象初始化器"><a href="#对象初始化器" class="headerlink" title="对象初始化器"></a>对象初始化器</h4><p><code>HeClass hh = new HeClass(2) { _me = 3 };</code><br>HeClass有个成员_me；<br>这个功能简直装逼用，没啥实用。效率和调用构造函数一样；<br>而且成员还必须是public，不然没法访问。。。。</p>
<p>##然后就是静态构造函数##<br>编写静态构造函数的一个原因是,类有一些静态字段或属性,需要在第一次使用类之前,从外部源中初始化这些静态字段和属性<br>由于并不确定它执行的时间，所以注意下此函数中对静态变量的赋值。</p>
<h4 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h4><p>给类加个static只是告诉编译器，这个类的所有成员必须是<code>static</code>类型的，不然就报错</p>
<h4 id="类和结构体区别"><a href="#类和结构体区别" class="headerlink" title="类和结构体区别"></a>类和结构体区别</h4><p>c#中类和结构体有个大大的区别， 类是引用类型，结构体是值类型。<br>也就是说：<br>直接的<code>=</code>操作对类来说是引用赋值（是浅拷贝过程）<br>直接的<code>=</code>操作对结构体来说是复制信息（是深拷贝）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyStru st = <span class="keyword">new</span> MyStru&#123; d=<span class="number">1</span>, a=<span class="number">2</span> &#125;;<span class="comment">//值类型还是在栈空间</span></div></pre></td></tr></table></figure>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>被嵌套在里面的类可以访问外部类的private成员，这和c++不同</p>
<p>对于嵌套类则不能把类型定义为protectcd、private和protected internal,<br>因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。<br><strong>但是</strong>,如果是嵌套类的话，这些修饰符就有了些意义。</p>
<h4 id="其它定义字段"><a href="#其它定义字段" class="headerlink" title="其它定义字段"></a>其它定义字段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> readonly <span class="keyword">int</span> MyInt = <span class="number">3</span>;<span class="comment">//表示这个字段只能在执行构造函数的过程中赋值，或由初始化赋值语句赋值。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MyInt;<span class="comment">//书上建议用const代替static，这样既避免出错也可以达到相同效果</span></div></pre></td></tr></table></figure>
<p>c#的extern导入的是外部程序集，经常和DllImport联合使用。</p>
<h4 id="继承使用"><a href="#继承使用" class="headerlink" title="继承使用"></a>继承使用</h4><p>c#的virtual、override、更是不同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"My"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"You"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> HeClass : YouClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"He"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//可以看出，如果想要重写，必须用virtual、override的配合</span></div><div class="line">    <span class="comment">//如果是 override sealed void... 配合的话，重写就此结束；派生类不能再重写。</span></div></pre></td></tr></table></figure></p>
<h4 id="partial部分关键字的使用"><a href="#partial部分关键字的使用" class="headerlink" title="partial部分关键字的使用"></a>partial部分关键字的使用</h4><p>partial关键字允许把类、结构或接口放在多个文件中，编译再变成一个类。<br>包括继承对象也会整合在一起（但是访问权限关键字不能整合）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Big1.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter1</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//Big2.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter2</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编译后就是</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TheBig :IMyInter1, IMyInter2 </div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面介绍了部分类，下面介绍部分方法</span></div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//部分方法的出现是为了解决要使用其它部分类的方法时，避免访问不到。</span></div><div class="line"><span class="comment">//但是它有以下毛病：</span></div><div class="line"><span class="comment">//0、只能存在于partial的类中</span></div><div class="line"><span class="comment">//1、总是私有类型，且不能有返回值</span></div><div class="line"><span class="comment">//2、使用的任何参数不能是out参数。但ref参数是可以的</span></div><div class="line"><span class="comment">//3、不能使用virtual、abstract、overrride、new、sealed、extern这些修饰符</span></div></pre></td></tr></table></figure></p>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝由默认隐式转换和MemberwiseClone来完成不用说。<br>来看深拷贝代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HeClass : ICloneable</div><div class="line">&#123;</div><div class="line">    HeClass(<span class="keyword">int</span> a)</div><div class="line">    &#123; <span class="number">_</span>me = a; &#125;</div><div class="line">    <span class="keyword">int</span> <span class="number">_</span>me;</div><div class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">Clone</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        HeClass c = <span class="keyword">new</span> HeClass(<span class="number">_</span>me);</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//发现必须继承ICloneable，并重写其函数</span></div><div class="line"><span class="comment">//还要注意new的构造函数传值问题。</span></div></pre></td></tr></table></figure></p>
<h4 id="重载符函数"><a href="#重载符函数" class="headerlink" title="重载符函数"></a>重载符函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> YouClass <span class="keyword">operator</span> +(YouClass a) &#123;</div><div class="line">        YouClass yy = <span class="keyword">new</span> YouClass();</div><div class="line">        <span class="keyword">return</span> yy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ClassA a;</div><div class="line">classB b;</div><div class="line">ClassC c;</div><div class="line">c = a + b;</div><div class="line">像这样的参数就必须是(ClassA, classB)，更重要的和顺序有关。</div></pre></td></tr></table></figure>
<p>如上操作符函数有这些要求：<br>必须是public<br>必须是static<br>返回值必须是原型</p>
<p>一元运算符：+、-、！、~、++、–、true、false<br>二元：+、-、*、/、%、&amp;、|、^、&lt;&lt;、&gt;&gt;<br>比较：==、!=、&lt;、&gt;、&lt;=、&gt;=</p>
<h4 id="隐式转换和显式转换"><a href="#隐式转换和显式转换" class="headerlink" title="隐式转换和显式转换"></a>隐式转换和显式转换</h4><p>对于引用类型来说，如下代码有误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">MyDrive bs = <span class="keyword">new</span> MyDrive();</div><div class="line">Program pro = (Program)bs;<span class="comment">//1</span></div><div class="line">Program pro = bs;<span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="comment">//如要成功，就需要支持隐式转换（2）和显式转换（1）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> implicit <span class="keyword">operator</span> <span class="title">Program</span><span class="params">(MyDrive s)</span> </span></div><div class="line">&#123; <span class="keyword">return</span> null; &#125;<span class="comment">//隐式</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Program</span><span class="params">(MyDrive s)</span></span></div><div class="line">&#123; <span class="keyword">return</span> null;  &#125;<span class="comment">//显式</span></div><div class="line"></div><div class="line">向MyDrive类添加如上函数便可，</div><div class="line">但是注意；相同函数隐式和显式只能存在一个，不能共存。</div></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h4><p>c#会像c++那样出现函数隐藏，但是它面对函数隐藏的时候会报警告的,如果要消除警告：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDriver:</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">int</span> <span class="title">ShowD</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//加个new，这样做并不会改变执行时的代码调用；只是去掉编译的警告而已。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>所有类都派生于<code>System.Object</code>，即使定义时没指定基类也会默认继承。</p>
<h4 id="abstract和sealed"><a href="#abstract和sealed" class="headerlink" title="abstract和sealed"></a>abstract和sealed</h4><ul>
<li><code>abstract</code>对类；修饰并不能阻止其函数的定义，也无法使函数默认变成可重写类型(函数依旧需要自己声明重写类型)；<br>它对类来说就只能是个说明是接口类的作用，实际作用并没有。</li>
<li><code>abstract</code>对函数；此函数为虚函数，默认重写类型</li>
<li><code>sealed</code>对类；这样表示此类不能被继承</li>
<li><code>sealed</code>对函数；只能对可重写类型的函数才能使用（virtual abstract），表示此函数子类不能重写，常和<code>override</code>联合使用</li>
</ul>
<h4 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h4><p><strong>首先这俩个操作是隐式的</strong><br>所有值类型均隐式派生自System.ValueType：<br>结构体、数值、整形、字符（char）、浮点、bool、枚举、派生于System.Nullable<br>如<code>int i = new int()</code>等价于<code>int i = 0</code></p>
<p>所有引用类型均隐式派生自System.object(包括它本身)：<br>数组：（派生于System.Array）数组的元素，不管是引用类型还是值类型，都存储在托管堆上；<br>类：class（派生于System.Object）；<br>接口：interface（接口不是一个“东西”，所以不存在派生于何处的问题。）；<br>委托：delegate（派生于System.Delegate）；<br>object：（System.Object的别名）；<br>字符串：string（System.String的别名）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object obj = <span class="number">1</span>;<span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>)obj;<span class="comment">//拆箱</span></div><div class="line"></div><div class="line"><span class="comment">//如上，c#中对值类型是放入栈中，对引用类型是放入堆中</span></div><div class="line"><span class="comment">//上面1是值，obj是引用。所以存在过程的转换</span></div><div class="line"><span class="comment">//这多余的转换会导致运行效率低下，所以请尽量避免。</span></div><div class="line"></div><div class="line"><span class="comment">//比如使用List&lt;obj&gt;来代替ArrayList;避免拆箱和装箱</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>ReactRouter-tutorial196</title>
    <link href="https://xuecat.github.io/2016/11/13/196/"/>
    <id>https://xuecat.github.io/2016/11/13/196/</id>
    <published>2016-11-13T02:16:25.000Z</published>
    <updated>2016-11-21T13:55:27.086Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a></p>
<ol>
<li>Router指定历史控件,切换路径历史直接：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">browserHistory.push(<span class="string">'/some/path'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>Route来控制布局,path指定路径(path有匹配规则)，component指定控件。<br><code>&lt;Link to=&quot;/about&quot;&gt;</code> 被点击后，会激活to指定的相应路径，并渲染上面path指定的控件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">            &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line">        &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//上面App包含了俩个，可以通过分别激活路径来切换显示区</div><div class="line"></div><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">    &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">        &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">    &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//三面三个同级，所以无论在哪个类里激活路径，都会跳转页面。</div><div class="line"></div><div class="line">//注意如果在App里面激活`/repos/:repoName`,则会先激活`/repos`再来激活它的子组件</div></pre></td></tr></table></figure>
<ol>
<li><p><code>&lt;IndexRoute component={Home}/&gt;</code> 设置默认渲染组件,如放上面1 - App下面，就会成为默认children渲染。<br> 如果想在列表有个组件相应的选中项 还要在App加个 <code>&lt;li&gt;&lt;NavLink to=&quot;/&quot; onlyActiveOnIndex={true}&gt;Home&lt;/NavLink&gt;&lt;/li&gt;</code></p>
</li>
<li><p>Contexts属性。</p>
</li>
</ol>
<ul>
<li>通过context传递属性的方式可以大量减少 通过显式的通过 props 逐层传递属性的方式。这样可以减少组件之间的直接依赖关系</li>
<li>如果你为一个组件指定了context，那么这个组件的子组件只要定义了contextTypes 属性，就可以访问到父组件指定的context了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">    &#125;,</div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.withContext(&#123;<span class="string">'name'</span>: <span class="string">'Jonas'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Outputs: "My name is: Jonas"</span></div><div class="line">    React.render(<span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">/////////////////////////////////////////////////////////////////////////</div><div class="line">//父类可以指定contextTypes，也可以指定childContextTypes；childContextTypes只是限定了传给子类的类型,无它就默认全下传。</div><div class="line">var A = React.createClass(&#123;</div><div class="line">    childContextTypes: &#123;</div><div class="line">         fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    getChildContext: function() &#123;//如果不书写这个函数，子类则无法获取</div><div class="line">         return &#123; fruit: "Banana"，name: "Apple" &#125;;</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">         return <span class="tag">&lt;<span class="name">B</span> /&gt;</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var B = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">        fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return <span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125; and my favorite fruit is: &#123;this.context.fruit&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;//由于父类限定了类型，所以如果是this.context.name就会报错</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">React.withContext(&#123;'name': 'Jonas'&#125;, function () &#123;//给A类，构造ContextTypes属性</div><div class="line">    React.render(<span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>关于跳转的方式,一种是用相应的history来push，一种是用context.router来push</li>
</ol>
<p>子类的<code>contextTypes</code>其实访问的是<code>Router</code>的<code>context</code>,<code>Router</code>有个叫router的<code>RouterContext</code>类型变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifen
    
    </summary>
    
      <category term="第三方库" scheme="https://xuecat.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>各个进制的表示195</title>
    <link href="https://xuecat.github.io/2016/11/07/195/"/>
    <id>https://xuecat.github.io/2016/11/07/195/</id>
    <published>2016-11-07T15:34:55.000Z</published>
    <updated>2016-11-07T15:39:41.577Z</updated>
    
    <content type="html"><![CDATA[<p>二进制好像vs2012以后才支持的吧，八进制表示在15上可以。</p>
<p> 二进制：0b011(3) 0B011(3)</p>
<p> 八进制: 00011(9); js是：0o011(9) 0O011(9)</p>
<p> 十六进制: 0x011(17) 0X011(17)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制好像vs2012以后才支持的吧，八进制表示在15上可以。&lt;/p&gt;
&lt;p&gt; 二进制：0b011(3) 0B011(3)&lt;/p&gt;
&lt;p&gt; 八进制: 00011(9); js是：0o011(9) 0O011(9)&lt;/p&gt;
&lt;p&gt; 十六进制: 0x011(17) 0X011(
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>js浅拷贝和深拷贝194</title>
    <link href="https://xuecat.github.io/2016/10/25/194/"/>
    <id>https://xuecat.github.io/2016/10/25/194/</id>
    <published>2016-10-25T13:39:04.000Z</published>
    <updated>2016-10-25T13:40:44.979Z</updated>
    
    <content type="html"><![CDATA[<p>浅拷贝：直接赋值<br><br>深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())<br></p>
<pre><code>var deepCopy = function(source) {
    var result={};
    for (var key in source) {
        result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
    }
return result; 
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅拷贝：直接赋值&lt;br&gt;&lt;br&gt;深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var deepCopy = function(source) {
    var res
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="语言" scheme="https://xuecat.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>node-npm指令193</title>
    <link href="https://xuecat.github.io/2016/10/24/193/"/>
    <id>https://xuecat.github.io/2016/10/24/193/</id>
    <published>2016-10-24T15:16:26.000Z</published>
    <updated>2016-10-24T15:18:57.980Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>npm查看全局安装过的包:<code>npm list -g --depth 0</code></p>
</li>
<li><p>删除node_module模块：<code>rimraf node_module</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;npm查看全局安装过的包:&lt;code&gt;npm list -g --depth 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除node_module模块：&lt;code&gt;rimraf node_module&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>es6和js笔记192</title>
    <link href="https://xuecat.github.io/2016/10/19/192/"/>
    <id>https://xuecat.github.io/2016/10/19/192/</id>
    <published>2016-10-19T13:57:07.000Z</published>
    <updated>2016-11-29T14:17:01.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量命令"><a href="#变量命令" class="headerlink" title="变量命令"></a>变量命令</h3><p>####. var和let </p>
<ul>
<li>let只在其块级作用域内有效，而var却全局有效。</li>
<li>区块中有let和const，则这个区块暂时性死区；即区块会对这些命令声明的变量一开始就形成封闭作用域，只要在声明前使用这些变量，就会报错（相反var不会）</li>
</ul>
<h4 id="const命令只保证变量指向地址不变，不能保证数据不变。"><a href="#const命令只保证变量指向地址不变，不能保证数据不变。" class="headerlink" title="const命令只保证变量指向地址不变，不能保证数据不变。"></a>const命令只保证变量指向地址不变，不能保证数据不变。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [];</div><div class="line">foo.prop = <span class="number">123</span>;<span class="comment">//这是被允许的</span></div><div class="line">foo = &#123;&#125;;<span class="comment">//这是不被允许的</span></div><div class="line"></div><div class="line"><span class="comment">//要完全冻结，参考如下代码</span></div><div class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.key(obj).forEach((key, value) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><h4 id="字符遍历。（好像用-也可以遍历）"><a href="#字符遍历。（好像用-也可以遍历）" class="headerlink" title="字符遍历。（好像用[]也可以遍历）"></a>字符遍历。（好像用<code>[]</code>也可以遍历）</h4><p>es5: for (var i=0; i<str.length; i++)="" {alert(str.charat(i));}="" <br=""><br>es6: for (let i=0 of str) {alert(i);}</str.length;></p>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>es6多了:<br><br>includes:返回布尔，表示十分找到参数字符串。第二个参数，表示开始搜索的位置<br>startsWith:返回布尔，表示参数字符串是否在源字符串的头部。第二个参数，表示开始搜索的位置<br>endsWith:返回布尔，表示参数字符串是否在源字符串的尾部。第二个参数，表示开始搜索的位置<br>repeat:返回一个新字符串，表示将原字符串重复n次</p>
<h4 id="模板字符串，使用反引号（-这个符号）"><a href="#模板字符串，使用反引号（-这个符号）" class="headerlink" title="模板字符串，使用反引号（`这个符号）"></a>模板字符串，使用反引号（`这个符号）</h4><p>普通字符： <code>dd&#39;\n&#39;asdf</code> 这里有换行<br>多行字符： 无需连接符，所有的空格、回车和缩进都会被保留在输出中。<br>变量嵌入：<code>hello ${name} are ${time}?</code> name和time是定义的变量。如果括号里面的不是字符串，则按一般规则转换为字符，如调用toString方法<br>函数调用：function tag(s, v, d); tag<code>hello ${a+b} ${a}</code>;<br>String的raw函数</p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>es5中String对象的方法，search、match、replace、split支持JS正则</p>
<h3 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>Number增加成员isFinite，isNaN.<br> es6把es5中的全局函数parseInt,parseFloat移植到了Number对象上。<br>Number成员，isSafeInteger范围在2的53次方</p>
<h4 id="Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s"><a href="#Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s" class="headerlink" title="Math对象,es6新增17个方法。它的方法都是静态方法:Math.abs(s)"></a>Math对象,es6新增17个方法。它的方法都是静态方法:<code>Math.abs(s)</code></h4><p>Math.trunc(4.2)//除去一个数的小数部分，返回整数<br><br>Math.sign();//判断一个数是正数(re:+1)、负数(re:-1)、还是零(re:0)、其它(re:NaN)<br>Math.cbrt();//计算一个数的立方根<br>对数、指数、平方等就不写了。</p>
<h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h4><ul>
<li><p>from函数；伪组数转换：</p>
<p>  let arraylike = {</p>
<pre><code>0: &apos;a&apos;,
1: &apos;b&apos;,
length: 2//这个属性必须有
</code></pre><p>  };//注意这是个对象，并不是数组</p>
</li>
</ul>
<p>es5中转换数组：[].slice.call(arraylike);或这么写Array.prototype.slice.call(arraylike);//[‘a’, ‘b’];<br>es6中转换数组：Array.from(arraylike);<br>//只要部署了Iterator接口的数据结构，和ES6的Set、Map。都可以转换。<br><br>//如果参数是数组，则返回新数组<br><br>//from还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组中<br></p>
<pre><code>function test(a,b,c,d) 
{ 
    var arg = Array.prototype.slice.call(arguments,1); 
    alert(arg); 
} 
test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d
</code></pre><h4 id="find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10"><a href="#find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10" class="headerlink" title="find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10"></a>find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10</h4><h4 id="fill填充数组"><a href="#fill填充数组" class="headerlink" title="fill填充数组"></a>fill填充数组</h4><h4 id="entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器"><a href="#entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器" class="headerlink" title="entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器"></a>entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器</h4><pre><code>for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {}
for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {}
//es6有遍历器对象
</code></pre><h4 id="includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true"><a href="#includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true" class="headerlink" title="includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true"></a>includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true</h4><h3 id="函数（函数参数默认压栈顺序，从左到右）"><a href="#函数（函数参数默认压栈顺序，从左到右）" class="headerlink" title="函数（函数参数默认压栈顺序，从左到右）"></a>函数（函数参数默认压栈顺序，从左到右）</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>es5 </p>
<pre><code>function log (x, y) { y = y || &apos;world&apos;;}
</code></pre><p>es6</p>
<pre><code>function log(x, y = &apos;world&apos;) {}
</code></pre><ul>
<li><p>解构和默认参数</p>
<pre><code>function foo({x, y = 5}) { console.log(x, y);}
foo({})//undefined, 5
foo({x:1})//1, 5
foo({x:1, y:2})//1, 2

function m1({x=0, y=0} = {}) {}
function m2({x, y} = {x:0, y:0}) {}
//上面俩个函数，在m({x:3})、m({})这种类型时，就不同
//它们顺序是先赋值参数，再执行构里面的默认值

//默认参数位置不用在尾部。但是调用要用undefined参数，如： f(undefined, 1)

//使用默认参数会相应减少length属性的值。(function(a, b, c = 5){}).length //2
</code></pre></li>
</ul>
<h4 id="rest参数和扩展运算符"><a href="#rest参数和扩展运算符" class="headerlink" title="rest参数和扩展运算符"></a>rest参数和扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</div><div class="line">        sum += val;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="comment">//有了rest后，就可以不使用arguments；只是注意rest参数是数组，且后面不能再有其它参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        array.push(item);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>扩展运算符也是加三个点(…)，好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arge = [<span class="number">4</span>, <span class="number">5</span>];</div><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(args, arge);</div><div class="line">args.concat(arge, arge);</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">f (<span class="number">-1</span>, ...args, ...[<span class="number">7</span>]);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line">args.push(...arge);</div><div class="line">[...args, ...arge, ...arge];</div></pre></td></tr></table></figure>
<h4 id="function有name属性（浏览器支持，es6才标准）"><a href="#function有name属性（浏览器支持，es6才标准）" class="headerlink" title="function有name属性（浏览器支持，es6才标准）"></a>function有name属性（浏览器支持，es6才标准）</h4><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数内部没有自己的this，导致内部的this就是外层代码块的this。<br><br>除此外，arguments、super、new.target也是指向外层函数对应的。</p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span> </span>&#123;&#125;<span class="comment">//此处，class对语法解析器来说是个关键字，为了让语法解析器解析为属性函数，必须加单引号</span></div><div class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="keyword">var</span> baz = &#123;foo: <span class="string">'bar'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span>() </span>&#123;&#125;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//书上说CommonJS模块输出变量，我感觉这代码很单独js文件时来借鉴，这样很方便导入使用</span></div><div class="line"><span class="keyword">var</span> ms = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ms = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;getItem, setItem, clear&#125;;</div><div class="line"><span class="comment">//等同于</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    getItem: getItem,</div><div class="line">    setItem: setItem,</div><div class="line">    clear: clear</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="属性名表达式-使用-来实现"><a href="#属性名表达式-使用-来实现" class="headerlink" title="属性名表达式(使用[]来实现)"></a>属性名表达式(使用[]来实现)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对属性的定义有俩种(es5只能用方法一)</span></div><div class="line">obj.foo = <span class="number">123</span>;</div><div class="line">obj[<span class="string">'f'</span> + <span class="string">'oo'</span>] = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//当多个定义的时候</span></div><div class="line"><span class="keyword">var</span> na = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> hh = <span class="string">'wq'</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="string">'pp'</span>: <span class="number">2</span>,</div><div class="line">    [<span class="string">'a'</span> + na]: <span class="number">3</span>,</div><div class="line">    [wq]: <span class="number">4</span>,</div><div class="line">    [<span class="string">'a'</span> + wq]: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//另外（表达式虽然可以使用，但是表达式计算的结果是全数字的话（数字开头也算），访问属性时会混乱出错）</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a.obj = <span class="number">3</span>;</div><div class="line">a[obj];<span class="comment">//error</span></div><div class="line">a[<span class="string">'obj'</span>];<span class="comment">//ok  因为点运算符后面总是字符串</span></div><div class="line"></div><div class="line"><span class="number">1</span>、对js来说属性名一定是字符串，不可能是其它对象</div><div class="line"><span class="number">2</span>、[]运算出来的只能是字符串，</div><div class="line"><span class="number">3</span>、[]里面的只能是对象，<span class="string">`['obj']`</span>是生产一个<span class="string">`obj`</span>的字符串，再转换</div></pre></td></tr></table></figure>
<h5 id="name的俩种特殊情况："><a href="#name的俩种特殊情况：" class="headerlink" title="name的俩种特殊情况："></a>name的俩种特殊情况：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></div></pre></td></tr></table></figure>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>除了个别（NaN、+0、-0）和<code>===</code>不一样，其它都一致。 </p>
<h4 id="Object。assign"><a href="#Object。assign" class="headerlink" title="Object。assign()"></a>Object。assign()</h4><p>它会从左向右，依次把元素叠加到第一个参数上，并返回第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; b: <span class="number">2</span>, c: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; c: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125; 注意assign只是浅拷贝</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></div><div class="line"><span class="comment">//如果组合的话，只进字符。</span></div><div class="line"></div><div class="line"><span class="comment">//Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性）</span></div><div class="line"><span class="comment">//也不拷贝不可枚举的属性（enumerable: false）。</span></div><div class="line"></div><div class="line"><span class="comment">//如果要保持继承链</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性的可枚举"><a href="#属性的可枚举" class="headerlink" title="属性的可枚举"></a>属性的可枚举</h4><p>es5有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性<br>es6多个<code>assign</code></li>
</ul>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>书上建议使用<br><code>Object.setPrototypeOf()</code>（写操作）、<br><code>Object.getPrototypeOf()</code>（读操作）、<br><code>Object.create()</code>（生成操作）代替 <code>__proto__</code>的直接操作，因为只有浏览器广泛支持，其它环境不一定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setPrototypeOf(obj, proto) &#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;<span class="comment">//setPrototypeOf的原型和它差不多，也就意味着这是浅拷贝。</span></div><div class="line"><span class="keyword">let</span> proto = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> obj = &#123; x: <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line"></div><div class="line">proto.y = <span class="number">20</span>;</div><div class="line">proto.z = <span class="number">40</span>;</div><div class="line"></div><div class="line">obj.x <span class="comment">// 10</span></div><div class="line">obj.y <span class="comment">// 20</span></div><div class="line">obj.z <span class="comment">// 40</span></div></pre></td></tr></table></figure>
<h4 id="Object-keys-和values相对"><a href="#Object-keys-和values相对" class="headerlink" title="Object.keys 和values相对"></a>Object.keys 和values相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.keys(obj)</div><div class="line"><span class="comment">// ["foo", "baz"]</span></div></pre></td></tr></table></figure>
<h4 id="Object-values-和keys相对"><a href="#Object-values-和keys相对" class="headerlink" title="Object.values 和keys相对"></a>Object.values 和keys相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.values(obj)</div><div class="line"><span class="comment">// ["bar", 42]</span></div></pre></td></tr></table></figure>
<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.entries(obj)</div><div class="line"><span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></div></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>从字面上理解，是为了属性引入新方法，同时避免重名的情况；保证属性名独一无二。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();<span class="comment">//它接收字符的，Symbol('a'),这样多了个字符串标识</span></div><div class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'H!'</span>&#125;;<span class="comment">//由于Symbol是函数，所以必须用属性名表达式</span></div><div class="line"></div><div class="line"><span class="comment">//还有一种使用方式是定义常量,感觉蛮实用的</span></div><div class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (color) &#123;</div><div class="line">    <span class="keyword">case</span> COLOR_RED:</div><div class="line">      <span class="keyword">return</span> COLOR_GREEN;</div><div class="line">    <span class="keyword">case</span> COLOR_GREEN:</div><div class="line">      <span class="keyword">return</span> COLOR_RED;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="魔术字符串"><a href="#魔术字符串" class="headerlink" title="魔术字符串"></a>魔术字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (shape) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: <span class="comment">// 魔术字符串</span></div><div class="line">getArea(<span class="string">'Triangle'</span>, &#123; width: <span class="number">100</span>, height: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></div><div class="line"><span class="comment">//作者建议为了减少代码的耦合性，应尽量用变量代替来消除魔术字符串。</span></div><div class="line"><span class="keyword">switch</span> (shape) &#123;</div><div class="line">    <span class="keyword">case</span> shapeType.triangle:</div><div class="line">getArea(shapeType.triangle, &#123; width: <span class="number">100</span>, height: <span class="number">100</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">//由于并不在意其值，所以用此。</span></div><div class="line"><span class="keyword">const</span> shapeType = &#123;</div><div class="line">  triangle: <span class="built_in">Symbol</span>()</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Symbol属性函数"><a href="#Symbol属性函数" class="headerlink" title="Symbol属性函数"></a>Symbol属性函数</h5><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。</p>
<p><code>Symbol.for()</code>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line">s1 === s2<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><code>Symbol.keyFor()</code>返回一个已登记的<code>Symbol</code>类型的key；<br>换句话说，它对<code>Symbol.for</code>返回成功的是能返回的。<br>对新建的<code>Symbol(&lt;string&gt;)</code>类型是无法返回的。</p>
<h3 id="Proxy-属于元编程"><a href="#Proxy-属于元编程" class="headerlink" title="Proxy(属于元编程)"></a>Proxy(属于元编程)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.count = <span class="number">1</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line">++obj.count</div><div class="line"><span class="comment">//  getting count!</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line"><span class="comment">//  2</span></div><div class="line"></div><div class="line"><span class="comment">//同一个拦截器，可以设置多个操作</span></div><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;value: args[<span class="number">1</span>]&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;, handler);</div><div class="line"></div><div class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></div><div class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></div><div class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></div><div class="line">fproxy.foo <span class="comment">// "Hello, foo"</span></div></pre></td></tr></table></figure>
<p><strong>总的来说有点像c++的操作符函数，但比操作符函数高级</strong><br>支持一下特性：</p>
<ol>
<li><code>get(target, propKey, receiver)</code>拦截对象属性读取</li>
<li><code>set(target, propKey, value, receiver)</code>拦截对象属性的设置 返回一个布尔值。</li>
<li><code>has(target, propKey)</code>拦截propKey in proxy的操作，以及对象的hasOwnProperty方法 返回一个布尔值。</li>
<li><code>deleteProperty(target, propKey)</code>拦截delete proxy[propKey]的操作 返回一个布尔值。</li>
<li><code>ownKeys(target)</code>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组</li>
<li><code>getOwnPropertyDescriptor(target, propKey)</code>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li><code>defineProperty(target, propKey, propDesc)</code>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li><code>preventExtensions(target)</code>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li><code>getPrototypeOf(target)</code>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li><code>isExtensible(target)</code>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li><code>setPrototypeOf(target, proto)</code>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</li>
<li><code>apply(target, object, args)</code>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li><code>construct(target, args)</code>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<p><strong>这个确实太多了，也没咋记，具体看书吧！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量命令&quot;&gt;&lt;a href=&quot;#变量命令&quot; class=&quot;headerlink&quot; title=&quot;变量命令&quot;&gt;&lt;/a&gt;变量命令&lt;/h3&gt;&lt;p&gt;####. var和let &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let只在其块级作用域内有效，而var却全局有效。&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
