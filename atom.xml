<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2016-11-22T12:19:30.693Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程198</title>
    <link href="https://xuecat.github.io/2016/11/21/198/"/>
    <id>https://xuecat.github.io/2016/11/21/198/</id>
    <published>2016-11-21T15:22:33.000Z</published>
    <updated>2016-11-22T12:19:30.693Z</updated>
    
    <content type="html"><![CDATA[<p>咋说呢，一直以来虽然知道<code>_beginthreadex</code>比较好。但是想起55用<code>CreateThread</code>，还是有点余悸。</p>
<p><strong>先看段原话</strong>：</p>
<p>有些CRT的函数象<code>malloc(), fopen(), _open(), strtok(), ctime(), 或localtime()</code>等函数需要专门的线程局部存储的数据块，<br><br>这个数据块通常需要在创建线程的时候就建立，如果使用<code>CreateThread</code>，这个数据块就没有建立，然后会怎样呢？<br><br>在这样的线程中还是可以使用这些函数而且没有出错，实际上函数发现这个数据块的指针为空时，会自己建立一个，<br><br>然后将其与线程联系在一起，这意味着如果你用<code>CreateThread</code>来创建线程，然后使用这样的函数，<br><br>会有一块内存在不知不觉中创建，遗憾的是，这些函数并不将其删除，而<code>CreateThread</code>和<code>ExitThread</code>也无法知道这件事，<br><br>于是就会有Memory Leak，在线程频繁启动的软件中(比如某些服务器软件)，迟早会让系统的内存资源耗尽！<br></p>
<hr>
<p><strong>说白了</strong>：如果多线程里面有CRT函数，最好使用<code>_beginthread</code>   <code>_beginthreadex</code>   <code>AfxBeginThread</code>(这个函数内部调用<code>_beginthreadex</code>创建处理的<code>CWinThread</code>专门的UI线程，可以通过发送接收message)</p>
<p>上面四个线程都有相应的<code>ExitThread或_endthread</code>；当然这些函数必须放入线程函数中。<br></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><h4 id="共同的毛病1："><a href="#共同的毛病1：" class="headerlink" title="共同的毛病1："></a>共同的毛病1：</h4><p><strong>虽然</strong>：在线程被创建成功后，都可以用<code>WaitForSingleObject( hThread, INFINITE );</code>来等待线程结束。<br><br><strong>但是这是不准的</strong>：一些<code>begin</code>函数本身就有<code>CloseHandle</code>了（如：<code>_beginthread</code>），再加上一些代码的<code>CloseHandle</code>，<br><br>所以无法正确知道线程的计数到底是在哪个时候被置为0，而且被置为0也不一定会是线程退出。<br><br>再说执行完线程函数后，<code>beging</code>函数本身有许多代码要执行。<br><br><strong>也就是说，最好不要这么等待线程结束，最好给个事件、原子等放在线程函数末尾，来判断线程是否结束。</strong></p>
<h4 id="共同的毛病2："><a href="#共同的毛病2：" class="headerlink" title="共同的毛病2："></a>共同的毛病2：</h4><p>如果在线程函数中调用退出函数，是会立即退出的。<br><br>也就是说连执行线程函数中，定义类的析构函数都来不及，就会直接退出线程返回，<br><br>如果那个类有析构有内存释放的话就糟糕了，会出现内存泄漏的。<br><br><strong>也就是说，最好不要用退出线程函数来退出线程，用return自然返回是最好的。</strong></p>
<h4 id="内存释放："><a href="#内存释放：" class="headerlink" title="内存释放："></a>内存释放：</h4><ul>
<li>内存释放这里也有个共同点； 创建线程后直接<code>CloseHandle</code>是可以的，这样的线程对象，在函数运行完了就自动释放（就算是_beginthread等有自释放代码的类型也同样适用）</li>
</ul>
<p><code>AfxBeginThread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><br><code>_beginthread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><br><code>_beginthreadex</code>必须手动<code>CloseHandle</code><br><br><code>CreateThread</code>必须手动<code>CloseHandle</code><br></p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p><code>AfxBeginThread</code>创建的线程比较庞大，一般的后台运行线程是没必要的<br><br><code>CreateThread</code>创建的线程无法使用CRT函数<br><br><code>_beginthread</code>创建的线程可以使用CRT函数，但引用官方的话来说：“使用 _beginthreadex 比 _beginthread 更为安全”；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咋说呢，一直以来虽然知道&lt;code&gt;_beginthreadex&lt;/code&gt;比较好。但是想起55用&lt;code&gt;CreateThread&lt;/code&gt;，还是有点余悸。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看段原话&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;有些CRT的函数象&lt;code&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="c函数" scheme="https://xuecat.github.io/tags/c%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="多线程" scheme="https://xuecat.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>c#入门经典197</title>
    <link href="https://xuecat.github.io/2016/11/21/197/"/>
    <id>https://xuecat.github.io/2016/11/21/197/</id>
    <published>2016-11-21T13:39:27.000Z</published>
    <updated>2016-11-23T16:16:11.408Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/r4.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>唉！！，es6正看着呢；去海外组了。。。。要补c#知识了</p>
<h4 id="NET程序："><a href="#NET程序：" class="headerlink" title=".NET程序："></a>.NET程序：</h4><p>使用.NET兼容语言（如c#）编写程序 -&gt; 把代码编译为CIL，存储在程序集中（即VS干的事） <br><br>-&gt; 执行时，先使用JIT编译器将代码编译为本机代码 -&gt; 在托管的CLR环境下运行本机代码。</p>
<h4 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h4><p>字节数增多：sbyte(1) short(2) int(4) long(8)<br>不同的是：其它类型的<code>unsigned</code>前面加<code>u</code>就好，唯独<code>byte</code>是0到255</p>
<p>转义字符(\”表示”)和字面量(100L 100F)都和c++差不多<br>多了个新功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> strTest = <span class="string">"wangqiu"</span>;</div><div class="line"><span class="built_in">string</span> strHEHE = $<span class="string">"&#123;strTest&#125; hehe"</span> + $<span class="string">" &#123;3+5&#125;de"</span>;<span class="comment">//这样是可以的哟，用法如同js的模板字符</span></div></pre></td></tr></table></figure>
<p><strong>差点忘了说，c#中变量类型其实全是System的类，也就意味着基本变量类型本身就有很多成员函数可以使用</strong></p>
<h4 id="语句："><a href="#语句：" class="headerlink" title="语句："></a>语句：</h4><p><code>switch</code>语句有点不同，多了个<code>goto case &lt;com&gt;:</code>，用来实现在这个case语句中跳转到其它case语句中</p>
<h5 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h5><p>用法基本同；c#多了层保险，可以用<code>checked((type))</code>出现的崩溃来保证，高字节向低字节转换;也可以默认设置强制转换加check；在书67页。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>用法和c++基本同；多了个指定类型，<code>enum Type : long</code>，这样指定枚举变量的类型。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//很智能，可以自动创建数组类，这样就能使用很多成员函数了。</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">6</span>, <span class="number">7</span>&#125;;<span class="comment">//new int[number],不能new int;</span></div></pre></td></tr></table></figure>
<p>数组的遍历可以用<code>for</code>也可以用<code>foreach(string f in fN)</code>;只是<code>foreach</code>里的f是只读属性，不能写。</p>
<ul>
<li>多元数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//几元数组就用几个`,`表示</span></div><div class="line"><span class="keyword">int</span>[,] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">int</span>[,] s = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;<span class="comment">//但是这种赋值会改变，声明的几元</span></div><div class="line"><span class="comment">//foreach会一行一行遍历全部元素。</span></div></pre></td></tr></table></figure>
<ul>
<li>锯齿数组<br>这个更该是数组中的数组，一个行不一定固定个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [][] d = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>&#125;,<span class="comment">//这行就一个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,<span class="comment">//这行俩个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">8</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>ReactRouter-tutorial196</title>
    <link href="https://xuecat.github.io/2016/11/13/196/"/>
    <id>https://xuecat.github.io/2016/11/13/196/</id>
    <published>2016-11-13T02:16:25.000Z</published>
    <updated>2016-11-21T13:55:27.086Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a></p>
<ol>
<li>Router指定历史控件,切换路径历史直接：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">browserHistory.push(<span class="string">'/some/path'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>Route来控制布局,path指定路径(path有匹配规则)，component指定控件。<br><code>&lt;Link to=&quot;/about&quot;&gt;</code> 被点击后，会激活to指定的相应路径，并渲染上面path指定的控件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">            &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line">        &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//上面App包含了俩个，可以通过分别激活路径来切换显示区</div><div class="line"></div><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">    &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">        &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">    &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//三面三个同级，所以无论在哪个类里激活路径，都会跳转页面。</div><div class="line"></div><div class="line">//注意如果在App里面激活`/repos/:repoName`,则会先激活`/repos`再来激活它的子组件</div></pre></td></tr></table></figure>
<ol>
<li><p><code>&lt;IndexRoute component={Home}/&gt;</code> 设置默认渲染组件,如放上面1 - App下面，就会成为默认children渲染。<br> 如果想在列表有个组件相应的选中项 还要在App加个 <code>&lt;li&gt;&lt;NavLink to=&quot;/&quot; onlyActiveOnIndex={true}&gt;Home&lt;/NavLink&gt;&lt;/li&gt;</code></p>
</li>
<li><p>Contexts属性。</p>
</li>
</ol>
<ul>
<li>通过context传递属性的方式可以大量减少 通过显式的通过 props 逐层传递属性的方式。这样可以减少组件之间的直接依赖关系</li>
<li>如果你为一个组件指定了context，那么这个组件的子组件只要定义了contextTypes 属性，就可以访问到父组件指定的context了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">    &#125;,</div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &lt;div&gt;My name is: &#123;this.context.name&#125;&lt;/div&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.withContext(&#123;<span class="string">'name'</span>: <span class="string">'Jonas'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Outputs: "My name is: Jonas"</span></div><div class="line">    React.render(&lt;A /&gt;, document.body);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/////////////////////////////////////////////////////////////////////////</div><div class="line">//父类可以指定contextTypes，也可以指定childContextTypes；childContextTypes只是限定了传给子类的类型,无它就默认全下传。</div><div class="line">var A = React.createClass(&#123;</div><div class="line">    childContextTypes: &#123;</div><div class="line">         fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    getChildContext: function() &#123;//如果不书写这个函数，子类则无法获取</div><div class="line">         return &#123; fruit: "Banana"，name: "Apple" &#125;;</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">         return &lt;B /&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var B = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">        fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return &lt;div&gt;My name is: &#123;this.context.name&#125; and my favorite fruit is: &#123;this.context.fruit&#125;&lt;/div&gt;;//由于父类限定了类型，所以如果是this.context.name就会报错</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">React.withContext(&#123;'name': 'Jonas'&#125;, function () &#123;//给A类，构造ContextTypes属性</div><div class="line">    React.render(&lt;A /&gt;, document.body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>关于跳转的方式,一种是用相应的history来push，一种是用context.router来push</li>
</ol>
<p>子类的<code>contextTypes</code>其实访问的是<code>Router</code>的<code>context</code>,<code>Router</code>有个叫router的<code>RouterContext</code>类型变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifen
    
    </summary>
    
      <category term="第三方库" scheme="https://xuecat.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>各个进制的表示195</title>
    <link href="https://xuecat.github.io/2016/11/07/195/"/>
    <id>https://xuecat.github.io/2016/11/07/195/</id>
    <published>2016-11-07T15:34:55.000Z</published>
    <updated>2016-11-07T15:39:41.577Z</updated>
    
    <content type="html"><![CDATA[<p>二进制好像vs2012以后才支持的吧，八进制表示在15上可以。</p>
<p> 二进制：0b011(3) 0B011(3)</p>
<p> 八进制: 00011(9); js是：0o011(9) 0O011(9)</p>
<p> 十六进制: 0x011(17) 0X011(17)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制好像vs2012以后才支持的吧，八进制表示在15上可以。&lt;/p&gt;
&lt;p&gt; 二进制：0b011(3) 0B011(3)&lt;/p&gt;
&lt;p&gt; 八进制: 00011(9); js是：0o011(9) 0O011(9)&lt;/p&gt;
&lt;p&gt; 十六进制: 0x011(17) 0X011(
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>js浅拷贝和深拷贝194</title>
    <link href="https://xuecat.github.io/2016/10/25/194/"/>
    <id>https://xuecat.github.io/2016/10/25/194/</id>
    <published>2016-10-25T13:39:04.000Z</published>
    <updated>2016-10-25T13:40:44.979Z</updated>
    
    <content type="html"><![CDATA[<p>浅拷贝：直接赋值<br><br>深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())<br></p>
<pre><code>var deepCopy = function(source) {
    var result={};
    for (var key in source) {
        result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
    }
return result; 
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅拷贝：直接赋值&lt;br&gt;&lt;br&gt;深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var deepCopy = function(source) {
    var res
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="语言" scheme="https://xuecat.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>node-npm指令193</title>
    <link href="https://xuecat.github.io/2016/10/24/193/"/>
    <id>https://xuecat.github.io/2016/10/24/193/</id>
    <published>2016-10-24T15:16:26.000Z</published>
    <updated>2016-10-24T15:18:57.980Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>npm查看全局安装过的包:<code>npm list -g --depth 0</code></p>
</li>
<li><p>删除node_module模块：<code>rimraf node_module</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;npm查看全局安装过的包:&lt;code&gt;npm list -g --depth 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除node_module模块：&lt;code&gt;rimraf node_module&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>es6和js笔记192</title>
    <link href="https://xuecat.github.io/2016/10/19/192/"/>
    <id>https://xuecat.github.io/2016/10/19/192/</id>
    <published>2016-10-19T13:57:07.000Z</published>
    <updated>2016-11-20T08:49:52.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量命令"><a href="#变量命令" class="headerlink" title="变量命令"></a>变量命令</h3><ol>
<li>var和let </li>
</ol>
<ul>
<li>let只在其块级作用域内有效，而var却全局有效。</li>
<li>区块中有let和const，则这个区块暂时性死区；即区块会对这些命令声明的变量一开始就形成封闭作用域，只要在声明前使用这些变量，就会报错（相反var不会）</li>
</ul>
<ol>
<li>const命令只保证变量指向地址不变，不能保证数据不变。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [];</div><div class="line">foo.prop = <span class="number">123</span>;<span class="comment">//这是被允许的</span></div><div class="line">foo = &#123;&#125;;<span class="comment">//这是不被允许的</span></div><div class="line"></div><div class="line"><span class="comment">//要完全冻结，参考如下代码</span></div><div class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.key(obj).forEach((key, value) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ol>
<li>字符遍历。（好像用<code>[]</code>也可以遍历）</li>
</ol>
<p>es5: for (var i=0; i<str.length; i++)="" {alert(str.charat(i));}="" <br=""><br>es6: for (let i=0 of str) {alert(i);}</str.length;></p>
<ol>
<li>字符函数</li>
</ol>
<p>es6多了:<br><br>includes:返回布尔，表示十分找到参数字符串。第二个参数，表示开始搜索的位置<br>startsWith:返回布尔，表示参数字符串是否在源字符串的头部。第二个参数，表示开始搜索的位置<br>endsWith:返回布尔，表示参数字符串是否在源字符串的尾部。第二个参数，表示开始搜索的位置<br>repeat:返回一个新字符串，表示将原字符串重复n次</p>
<ol>
<li>模板字符串，使用反引号（`这个符号）</li>
</ol>
<p>普通字符： <code>dd&#39;\n&#39;asdf</code> 这里有换行<br>多行字符： 无需连接符，所有的空格、回车和缩进都会被保留在输出中。<br>变量嵌入：<code>hello ${name} are ${time}?</code> name和time是定义的变量。如果括号里面的不是字符串，则按一般规则转换为字符，如调用toString方法<br>函数调用：function tag(s, v, d); tag<code>hello ${a+b} ${a}</code>;<br>String的raw函数</p>
<ol>
<li>正则</li>
</ol>
<p>es5中String对象的方法，search、match、replace、split支持JS正则</p>
<h3 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h3><ol>
<li><p>数值<br>Number增加成员isFinite，isNaN.<br> es6把es5中的全局函数parseInt,parseFloat移植到了Number对象上。<br>Number成员，isSafeInteger范围在2的53次方</p>
</li>
<li><p>Math对象,es6新增17个方法。它的方法都是静态方法:<code>Math.abs(s)</code></p>
</li>
</ol>
<p>Math.trunc(4.2)//除去一个数的小数部分，返回整数<br><br>Math.sign();//判断一个数是正数(re:+1)、负数(re:-1)、还是零(re:0)、其它(re:NaN)<br>Math.cbrt();//计算一个数的立方根<br>对数、指数、平方等就不写了。</p>
<ol>
<li>Array数组</li>
</ol>
<ul>
<li><p>from函数；伪组数转换：</p>
<p>  let arraylike = {</p>
<pre><code>0: &apos;a&apos;,
1: &apos;b&apos;,
length: 2//这个属性必须有
</code></pre><p>  };//注意这是个对象，并不是数组</p>
</li>
</ul>
<p>es5中转换数组：[].slice.call(arraylike);或这么写Array.prototype.slice.call(arraylike);//[‘a’, ‘b’];<br>es6中转换数组：Array.from(arraylike);<br>//只要部署了Iterator接口的数据结构，和ES6的Set、Map。都可以转换。<br><br>//如果参数是数组，则返回新数组<br><br>//from还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组中<br></p>
<pre><code>function test(a,b,c,d) 
{ 
    var arg = Array.prototype.slice.call(arguments,1); 
    alert(arg); 
} 
test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d
</code></pre><ul>
<li><p>find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10</p>
</li>
<li><p>fill填充数组</p>
</li>
<li><p>entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器</p>
<p>  for (let index of [‘a’, ‘b’].keys()) {}<br>  for (let [index, elem] of [‘a’, ‘b’].entries()) {}<br>  //es6有遍历器对象</p>
</li>
<li><p>includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true</p>
</li>
</ul>
<h3 id="函数（函数参数默认压栈顺序，从左到右）"><a href="#函数（函数参数默认压栈顺序，从左到右）" class="headerlink" title="函数（函数参数默认压栈顺序，从左到右）"></a>函数（函数参数默认压栈顺序，从左到右）</h3><ol>
<li>函数参数的默认值 </li>
</ol>
<p>es5 </p>
<pre><code>function log (x, y) { y = y || &apos;world&apos;;}
</code></pre><p>es6</p>
<pre><code>function log(x, y = &apos;world&apos;) {}
</code></pre><ul>
<li><p>解构和默认参数</p>
<pre><code>function foo({x, y = 5}) { console.log(x, y);}
foo({})//undefined, 5
foo({x:1})//1, 5
foo({x:1, y:2})//1, 2

function m1({x=0, y=0} = {}) {}
function m2({x, y} = {x:0, y:0}) {}
//上面俩个函数，在m({x:3})、m({})这种类型时，就不同
//它们顺序是先赋值参数，再执行构里面的默认值

//默认参数位置不用在尾部。但是调用要用undefined参数，如： f(undefined, 1)

//使用默认参数会相应减少length属性的值。(function(a, b, c = 5){}).length //2
</code></pre></li>
</ul>
<ol>
<li>rest参数和扩展运算符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</div><div class="line">        sum += val;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="comment">//有了rest后，就可以不使用arguments；只是注意rest参数是数组，且后面不能再有其它参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        array.push(item);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>扩展运算符也是加三个点(…)，好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arge = [<span class="number">4</span>, <span class="number">5</span>];</div><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(args, arge);</div><div class="line">args.concat(arge, arge);</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">f (<span class="number">-1</span>, ...args, ...[<span class="number">7</span>]);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line">args.push(...arge);</div><div class="line">[...args, ...arge, ...arge];</div></pre></td></tr></table></figure>
<ol>
<li><p>function有name属性（浏览器支持，es6才标准）</p>
</li>
<li><p>箭头函数</p>
</li>
</ol>
<p>箭头函数内部没有自己的this，导致内部的this就是外层代码块的this。<br><br>除此外，arguments、super、new.target也是指向外层函数对应的。</p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ol>
<li>属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span> </span>&#123;&#125;<span class="comment">//此处，class对语法解析器来说是个关键字，为了让语法解析器解析为属性函数，必须加单引号</span></div><div class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="keyword">var</span> baz = &#123;foo: <span class="string">'bar'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span>() </span>&#123;&#125;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//书上说CommonJS模块输出变量，我感觉这代码很单独js文件时来借鉴，这样很方便导入使用</span></div><div class="line"><span class="keyword">var</span> ms = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ms = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;getItem, setItem, clear&#125;;</div><div class="line"><span class="comment">//等同于</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    getItem: getItem,</div><div class="line">    setItem: setItem,</div><div class="line">    clear: clear</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>属性名表达式(使用[]来实现)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对属性的定义有俩种(es5只能用方法一)</span></div><div class="line">obj.foo = <span class="number">123</span>;</div><div class="line">obj[<span class="string">'f'</span> + <span class="string">'oo'</span>] = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//当多个定义的时候</span></div><div class="line"><span class="keyword">var</span> na = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> hh = <span class="string">'wq'</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    pro: <span class="number">1</span>,</div><div class="line">    <span class="string">'pp'</span>: <span class="number">2</span>,</div><div class="line">    [<span class="string">'a'</span> + na]: <span class="number">3</span>,</div><div class="line">    [wq]: <span class="number">4</span>,</div><div class="line">    [<span class="string">'a'</span> + wq]: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//虽然第一种和第二种都可以，但是遇见编译器关键字时第一种就会出错。所以建议用第二种来实现定义</span></div><div class="line"><span class="comment">//另外（表达式虽然可以使用，但是表达式计算的结果是全数字的话（数字开头也算），访问属性时会混乱出错）</span></div><div class="line"></div><div class="line"><span class="comment">//访问属性时</span></div><div class="line">obj[pro];<span class="comment">//ok</span></div><div class="line">obj[<span class="string">'pro'</span>];<span class="comment">//error</span></div><div class="line">obj[pp];<span class="comment">//error</span></div><div class="line">obj[<span class="string">'pp'</span>];<span class="comment">//ok</span></div><div class="line">obj.pro;<span class="comment">//ok</span></div><div class="line">obj.pp;<span class="comment">//ok</span></div><div class="line"></div><div class="line">obj.a4;<span class="comment">//ok</span></div><div class="line">obj[<span class="string">'a4'</span>];<span class="comment">//ok</span></div><div class="line">obj[a4];<span class="comment">//error</span></div><div class="line">obj[wq];<span class="comment">//ok</span></div><div class="line">obj[<span class="string">'awq'</span>];<span class="comment">//ok</span></div><div class="line">obj[awq];<span class="comment">//error</span></div><div class="line">obj.a4, obj.wq, obj.awq;<span class="comment">//ok</span></div><div class="line"><span class="comment">//从上看到，访问属性时最好使用`.`的形式。实在要用表达式的形式就要注意定义时候的形式。</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量命令&quot;&gt;&lt;a href=&quot;#变量命令&quot; class=&quot;headerlink&quot; title=&quot;变量命令&quot;&gt;&lt;/a&gt;变量命令&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;var和let &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;let只在其块级作用域内有效，而var却全局有效。&lt;/
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS-Google语法191</title>
    <link href="https://xuecat.github.io/2016/10/17/191/"/>
    <id>https://xuecat.github.io/2016/10/17/191/</id>
    <published>2016-10-17T13:09:30.000Z</published>
    <updated>2016-11-20T08:49:51.513Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>如果一个值是恒定的，它命名中的字母要全部大写（如 <code>CONSTANT_VALUE_CASE</code> ）</li>
<li><p>一定要分号，js是弱语言，很多时候不要分号也能执行。但是容易出错。</p>
<p> //函数表达式后面要分号结束，但是函数声明就不需要</p>
<pre><code>var foo = function() {
    return true;
};  // 这里要分号

function foo() {
    return true;
}  // 这里不用分号
</code></pre></li>
<li><p>不要在块内函数声明，应该使用一个变量初始化函数表达式在块内定义一个函数块</p>
</li>
<li>为了最大的可移植性和兼容性，总是使用标准功能而不是非标准功能（例如，采用 string.charAt(3) 而非 string[3] ，用DOM的功能访问元素而不是使用特定于一个具体应用的简写）。</li>
<li><p>原始类型的包装对象，</p>
<pre><code>var x = new Boolean(false);
if (x) {//这是错误的，因为x是个object，而不是bool，正确该是var x = Boolean(0);
    alert(&apos;hi&apos;);  //显示“hi”。
}
</code></pre></li>
<li><p>方法和属性定义</p>
</li>
</ol>
<p>虽然有多种使用“new”关键词来创建对象方法和属性的途径，首选的创建方法的途径是：</p>
<pre><code>Foo.prototype.bar = function() {
    /* ... */
};//好像这样能提供性能
</code></pre><p>其他特性的首选创建方式是在构造函数中初始化字段：</p>
<pre><code>/** @constructor */
function Foo() {
    this.bar = value;
}
</code></pre><ol>
<li>删除，使用this.foo == null,而不是delete</li>
<li>遍历数组使用for循环 而不是for-in</li>
<li>多行字符不要使用连接行符，直接’+’</li>
<li>构建数组对象用字面量，而不是构造函数。</li>
</ol>
<p>//问题在构造只有一个元素的函数时</p>
<pre><code>var a = new Array(x); //它表示的是开辟一个x大小的数组，内部赋值undifinew；而不是开辟一个数组，内部赋值x；
var a = [x1, x2];
var a = [x1];
var a = [];
</code></pre><p>对象构造函数，为了一致性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o2.a = <span class="number">0</span>;</div><div class="line">    o2.b = <span class="number">1</span>;</div><div class="line">    o2.c = <span class="number">2</span>;</div><div class="line">    o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;</div><div class="line"></div><div class="line">改为：</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = &#123;</div><div class="line">        a: <span class="number">0</span>,</div><div class="line">        b: <span class="number">1</span>,</div><div class="line">        c: <span class="number">2</span>,</div><div class="line">        <span class="string">'strange key'</span>: <span class="number">3</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//关于对象属性的设置和获取，也最好使用字面量；请看`192`第15条</span></div></pre></td></tr></table></figure>
<ol>
<li>强烈禁止修改如 Object.prototype 和 Array.prototype 等对象的原型。</li>
<li>不要使用条件注释；条件注释会在运行时改变JavaScript语法树，阻碍自动化工具。</li>
<li>私有 属性和方法应该以下划线开头命名</li>
<li>保护 属性和方法应该以无下划线开头命名（像公共属性和方法一样）。</li>
<li>可选函数参数以 opt_ 开头。</li>
<li>参数数目可变的函数应该具有以 var_args 命名的最后一个参数。</li>
<li>为了避免在大小写敏感的平台上引起混淆，文件名应该小写。文件名应该以 .js 结尾，并且应该不包含除了 - 或 <em> （相比较 </em> 更推荐 - ）以外的其它标点</li>
<li><p>括号书写：</p>
<pre><code>if (something) {
} else {
}
</code></pre></li>
<li><p>多行，对象和数组初始化</p>
<pre><code>var arr = [1, 2, 3];  //之后无空格[或之前]
var obj = {a: 1, b: 2, c: 3};  //之后无空格[或之前]

//不要像这样：

WRONG_Object.prototype = {
    a          : 0,
    b          : 1,
    lengthyName: 2
};
</code></pre></li>
<li><p>匿名函数传递</p>
<pre><code>prefix.something.reallyLongFunctionName(&apos;whatever&apos;, function(a1, a2) {
    if (a1.equals(a2)) {
        someOtherLongFunctionName(a1);
    } else {
        andNowForSomethingCompletelyDifferent(a2.parrot);
    }
});

var names = prefix.something.myExcellentMapFunction(
    verboselyNamedCollectionOfItems,
    function(item) {
        return item.name;
    });
</code></pre></li>
<li><p>字符串使用单引号，虽然js不区分单引号和双引号。<br><br>但是一般html的属性用的是双引号。所以当js字符串为了区分html和转义，最好使用单引号。</p>
</li>
<li>注释可以参考jsdoc的做法</li>
<li><p>布尔类型</p>
<pre><code>下边的布尔表达式都返回false：
//@
null
undefined
&apos;&apos;空字符串
数字0
//但是要小心，因为以下这些返回true：
字符串&quot;0&quot;
[]空数组
{}空对象

//@所以 while (x != null) {}这样不好， 该是 while(x) {}
//if (y != null &amp;&amp; y != &apos;&apos;) {} 也改成 if (y) {}

//@二元布尔操作符是可短路的,所以
    var win;
    if (opt_win) {
        win = opt_win;
    } else {
        win = window;
    }
    //可以改成：
    function foo(opt_win) {
        var win = opt_win || window;
    }

    if (node) {
        if (node.kids) {
            if (node.kids[index]) {
                foo(node.kids[index]);
            }
        }
    }
    //可以改成：
    var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];
    if (kid) {
        foo(kid);
    }
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;如果一个值是恒定的，它命名中的字母要全部大写（如 &lt;code&gt;CONSTANT_VALUE_CASE&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一定要分号，js是弱语言，很多时候不要分号也能执行。但是容易出错。&lt;/p&gt;
&lt;p&gt; //函数表达式后面要分号结束，但是
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React记录190</title>
    <link href="https://xuecat.github.io/2016/10/16/190/"/>
    <id>https://xuecat.github.io/2016/10/16/190/</id>
    <published>2016-10-16T08:57:00.000Z</published>
    <updated>2016-11-21T13:49:10.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. this.props.children</strong><br>它是链表没错(当只有一个时，是string之类元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">React.Children.map(<span class="keyword">this</span>.props.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &lt;li&gt;&#123;child&#125;&lt;/li&gt;;</div><div class="line">        &#125;)</div><div class="line"><span class="comment">//每个child是一个ReactElement的object，可能ReactElement有默认的隐式处理吧_shadowChildren之类吧！</span></div></pre></td></tr></table></figure>
<p>此句，一直不明白为何object能当字符处理。</p>
<p><strong>2. markdown显示</strong><br>使用remarkable库，可以支持markdown格式显示语句。<br><br>但是不能直接render解析（虽然表面看是对的），好像react做了XSS 攻击的保护。<br><br>解析后的语句只能放入节点属性中：dangerouslySetInnerHTML={ __html: md.render(this.props.children.toString()) }<br><br>值得注意的是，它支持的markdown语法是最新的，也就是说有些语法严格和空格有关(如<code># d</code>必须空格)</p>
<p><strong>3. react key添加</strong><br>我在用map的时候，被警告必须加key。react对dom做遍历的时候，会根据data-reactid生成虚拟dom树。如果你没有手动的添加unique constant key的话，react是无法记录你的dom操作的。</p>
<p><strong>4. createClass函数问题</strong><br>createClass创建的方法</p>
<p><code>rawMarkup: function() {}</code></p>
<p>要<code>this.rawMarkup()</code>才能访问到；晕，刚居然没注意。</p>
<p><strong>5. eslint安装</strong><br>eslint和eslint插件必须全部 全局安装。局部安装老是报错，无法找到插件。</p>
<p><strong>6. react-es6</strong><br>这个由于很多，只说下属性的设置；<br>es5对类属性设置是用： <code>render: function(){}</code><br><br>es6对类属性设置是用：<code>render() {}</code><br><br>居然看半天没发现。<br><a href="http://blog.csdn.net/wangzengdi/article/details/50719395" target="_blank" rel="external">http://blog.csdn.net/wangzengdi/article/details/50719395</a></p>
<p><strong>7. 无状态的函数式组件</strong><br>除了正统的rn创建外；还有个创建组件的方法<br></p>
<p>声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Pane = (props) =&gt; &lt;div&gt;&#123;props.children&#125;&lt;/div&gt;;</div><div class="line">Pane.propTypes = &#123;</div><div class="line">  label: React.PropTypes.string.isRequired,</div><div class="line">  children: React.PropTypes.element.isRequired</div><div class="line">&#125;;</div><div class="line"><span class="comment">//使用：</span></div><div class="line">&lt;Pane label=<span class="string">"asdf"</span> /&gt;</div></pre></td></tr></table></figure>
<p>注意俩点：</p>
<ol>
<li>不能有生命周期方法</li>
<li>不能有ref（实例dom属性，React.findDOMNode）</li>
</ol>
<p><strong>8. children isrequired</strong><br><code>children: React.PropTypes.element.isRequired</code></p>
<p><strong>9. react全家桶</strong><br>webpack和其它基本已经知道了；给个前端ui库吧：reactui库有个ant design 和material ui、 boostrap<br><br>flux网上说文档又臭又长，转redux</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. this.props.children&lt;/strong&gt;&lt;br&gt;它是链表没错(当只有一个时，是string之类元素)&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
      <category term="第三方库" scheme="https://xuecat.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>换系统时要保存的文件189</title>
    <link href="https://xuecat.github.io/2016/10/12/189/"/>
    <id>https://xuecat.github.io/2016/10/12/189/</id>
    <published>2016-10-12T15:32:07.000Z</published>
    <updated>2016-11-12T08:33:54.444Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/e1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<ul>
<li>vscode 插件项</li>
<li>桌面的<code>笔记.txt</code></li>
</ul>
<p>今天真是超级扯淡的一天：</p>
<ul>
<li>sp1系统和其它非ultimate系统（msdn我告诉你），没有系统更新模块；sp1到无所谓，模块集成了，只是没法英文系统而已。</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！ 尼玛，它会直接破坏小马的系统激活，气死我了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>CFile各属性笔记188</title>
    <link href="https://xuecat.github.io/2016/09/27/188/"/>
    <id>https://xuecat.github.io/2016/09/27/188/</id>
    <published>2016-09-27T14:09:47.000Z</published>
    <updated>2016-09-27T14:39:50.818Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今日为楼下写多线程的文件操作测试程序，记录下。</strong></p>
<p>CFile::shareDenyNone 表示允许其它进/线程访问（多线程时便用此CFile::shareDenyNone和CFile::shareDenyNone搭配，对文件边读边写）</p>
<p>CFile::shareDenyRead 禁止其它进/线程读操作</p>
<p>CFile::shareDenyWrite 禁止其它进/线程写操作</p>
<p>CFile::shareExclusive 禁止其它进/线程读写操作</p>
<p>CFile::modeNoTruncate 它必须要和CFile::modeCreate连用保证稳定性。好吧对于它一般是写操作时用的多，<br><br>CFile::modeCreate会清零文件，即原来文件80k，你写入50k，这下文件就只有50k新数据。<br><br>CFile::modeNoTruncate不会清零文件，即原来80k，写入50k，这下文件就有50k新数据和30k旧数据。如果想对尾部添加的话直接seek到end就好<br></p>
<p><strong>CFile::osNoBuffer 不会有系统缓存。它太特殊了，今天就卡这儿；它对文件操作必须按照卷大小来操作：也就是说添加此属性的CFile，seek、read、write的操作大小必须是1024的倍数</strong> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;今日为楼下写多线程的文件操作测试程序，记录下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CFile::shareDenyNone 表示允许其它进/线程访问（多线程时便用此CFile::shareDenyNone和CFile::shareDenyNone搭配，对文件边
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>npm install注意187</title>
    <link href="https://xuecat.github.io/2016/09/26/187/"/>
    <id>https://xuecat.github.io/2016/09/26/187/</id>
    <published>2016-09-26T15:34:46.000Z</published>
    <updated>2016-09-29T00:24:42.293Z</updated>
    
    <content type="html"><![CDATA[<p><code>--save-dev</code> 是你开发时候依赖的东西，<code>--save</code> 是你发布之后还依赖的东西。</p>
<p>比如，你写 ES6 代码，如果你想编译成 ES5 发布那么 babel 就是devDependencies。<br><br>如果你用了 jQuery，由于发布之后还是依赖jQuery，所以是dependencies。</p>
<p>但是在 npm 里面除了二进制的依赖，似乎也不用区分是不是dev。<br><br>因为使用npm就是自己编译的意思，而不使用npm直接拿编译后的版本的，这些依赖项也看不到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;--save-dev&lt;/code&gt; 是你开发时候依赖的东西，&lt;code&gt;--save&lt;/code&gt; 是你发布之后还依赖的东西。&lt;/p&gt;
&lt;p&gt;比如，你写 ES6 代码，如果你想编译成 ES5 发布那么 babel 就是devDependencies。&lt;br&gt;&lt;b
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>google调试react186</title>
    <link href="https://xuecat.github.io/2016/09/25/186/"/>
    <id>https://xuecat.github.io/2016/09/25/186/</id>
    <published>2016-09-25T09:01:40.000Z</published>
    <updated>2016-10-18T16:36:11.529Z</updated>
    
    <content type="html"><![CDATA[<p>今天死活断点不了，google了好久；发现有个<code>debugger</code>放入代码中就好了，可以看堆栈了。<br><br>断点不了的问题至今没找到，气死人了。！</p>
<p>好吧v2ex果然大神多，jsx需要编译产生sourcemap后才能被调试，所以webpack是标配。另外react-hot-loader（js库）和react-devtools（google插件）不错</p>
<p><code>Create React App</code>和<code>generator-react-webpack</code>会自动生成react项目，使用webpack自动打包，但是<code>dev-source-map</code>模式下无法调试。<br><br>其它模式参考：<a href="https://segmentfault.com/a/1190000004280859" target="_blank" rel="external">https://segmentfault.com/a/1190000004280859</a></p>
<p>调试的jsx，一般都是被打包成js的，很好看，也方便调试（就google-&gt;source 那里找源码有点不好找，打包多了）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天死活断点不了，google了好久；发现有个&lt;code&gt;debugger&lt;/code&gt;放入代码中就好了，可以看堆栈了。&lt;br&gt;&lt;br&gt;断点不了的问题至今没找到，气死人了。！&lt;/p&gt;
&lt;p&gt;好吧v2ex果然大神多，jsx需要编译产生sourcemap后才能被调试，所以web
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
      <category term="google-chrome" scheme="https://xuecat.github.io/tags/google-chrome/"/>
    
  </entry>
  
  <entry>
    <title>JS中单引号与双引号的一个区别185</title>
    <link href="https://xuecat.github.io/2016/09/25/185/"/>
    <id>https://xuecat.github.io/2016/09/25/185/</id>
    <published>2016-09-25T02:30:36.000Z</published>
    <updated>2016-09-25T04:44:40.333Z</updated>
    
    <content type="html"><![CDATA[<p>一般Javascript资料里面，很少区分单引号(‘)和双引号(“)，认为它们作用相同，今天发现有一处不同点，举例如下：</p>
<pre><code>在一段JS语句中，希望通过编程在网页中动态添加一个命令按钮， 则基本实现语句如下所示 

      var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定/&gt;&quot;);
      document.body.appendChild(btnOk2);
若要在点击按钮后显示一个提示信息，则要对其onclick事件编程，此时有多种方法可以实现。

1. 添加函数

      onclick=clickOK();//clickOK()为单独定义的函数

      function clickOK(){

         alert(&quot;确定&quot;);

      }

2. 使用匿名函数

      onclick=function(){alert(&apos;确定&apos;)};//注意，此处alert内的提示信息应使用单引号，若使用双引号则放入整个input 时语法不正确

3. 直接使用javascript语句，单引号

      onclick=&apos;javascript:{alert(&apos;确定&apos;)&apos;;//注意，此语句语法没问题，但却不能正常执行，点击按钮时无结果，具体原因不详，也未深究

4. 直接使用javascript语句，双引号

      由于要放入input语句中，因此alert不能直接使用双引号，使用转义符/完成

      onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;;//注意，此语句语法没问题，也能够正常执行

使用第4中方法的完整实例语句如下：

var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定 onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;/&gt;&quot;);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般Javascript资料里面，很少区分单引号(‘)和双引号(“)，认为它们作用相同，今天发现有一处不同点，举例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在一段JS语句中，希望通过编程在网页中动态添加一个命令按钮， 则基本实现语句如下所示 

      var btnOk2
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>critical_section临界区注意事项184</title>
    <link href="https://xuecat.github.io/2016/09/22/184/"/>
    <id>https://xuecat.github.io/2016/09/22/184/</id>
    <published>2016-09-22T13:50:33.000Z</published>
    <updated>2016-09-22T13:53:00.253Z</updated>
    
    <content type="html"><![CDATA[<p>EnterCriticalSection作为临界区</p>
<p>critical_section效率要高一些，因为是针对同一个进程的。<br>mutex是针对整个操作系统的。</p>
<p>//1.测试同一线程两次EnterCriticalSection会不会阻塞<br>//答案:不会<br>/*</p>
<p>//2.测试同一线程两次EnterCriticalSection，调用一次LeaveCriticalSection 另一个线程是否可以以EnterCriticalSection<br>//答案:不可以 两次EnterCriticalSection 必须调用 LeaveCriticalSection两次</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EnterCriticalSection作为临界区&lt;/p&gt;
&lt;p&gt;critical_section效率要高一些，因为是针对同一个进程的。&lt;br&gt;mutex是针对整个操作系统的。&lt;/p&gt;
&lt;p&gt;//1.测试同一线程两次EnterCriticalSection会不会阻塞&lt;br&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="多线程" scheme="https://xuecat.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在VSCode开发react环境过程IDE183</title>
    <link href="https://xuecat.github.io/2016/09/21/183/"/>
    <id>https://xuecat.github.io/2016/09/21/183/</id>
    <published>2016-09-21T15:54:37.000Z</published>
    <updated>2016-11-13T02:15:32.030Z</updated>
    
    <content type="html"><![CDATA[<p>###过程多了186也有，这里这说下开发环境，有利工具</p>
<ol>
<li><p>代码语法提示，插件ESLint；它对写的代码进行语法错误提示，特别是配置了react的插件后，对react属性、状态等书写有全面提示。</p>
</li>
<li><p>代码自动补全，node插件Typings和vsc插件Typings suto installer，前者全局安装，后者会自动把package.jason的TS（微软的TypingScript）包全下全</p>
</li>
<li><p>Debugger for Chrome,这个很好就是配置不好弄，用google远程调试协议来达到vsc本地调试，它的example可以直接下在本地使用。<br><br>example项目确实让人见识了很多东西；</p>
</li>
<li><p>Reactjs code snippets,这个很好专门的react的自动补全。</p>
</li>
<li><p>emment（内置，它简直为前端而生，语法很好使）；它默认是不支持js的，jsx倒是可以。<br><br>我google和官网了很久都没找到提示，最后没法，去git看看（原来git官网的doc是实时更新的，比官网的doc更新都勤快，以后只去git去看doc了）<br><br>在<code>.vscode</code>目录新建一个<code>settings.json</code>，加上<code>{&quot;emmet.syntaxProfiles&quot;: { &quot;javascript&quot;: &quot;html&quot; }}</code>便好了</p>
</li>
<li><p>调试和堆栈过程放186吧。</p>
</li>
</ol>
<ul>
<li><p>单个js调试，launch.json的配置  <a href="https://segmentfault.com/a/1190000004136202" target="_blank" rel="external">https://segmentfault.com/a/1190000004136202</a></p>
<p>  “name”: “启动”,<br>  “type”: “node”,<br>  “request”: “launch”,<br>  “program”: “${workspaceRoot}/demo01/tt.js”,</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###过程多了186也有，这里这说下开发环境，有利工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码语法提示，插件ESLint；它对写的代码进行语法错误提示，特别是配置了react的插件后，对react属性、状态等书写有全面提示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码自动补全，n
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="vscode" scheme="https://xuecat.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>仿函数和配接器的使用182</title>
    <link href="https://xuecat.github.io/2016/09/17/182/"/>
    <id>https://xuecat.github.io/2016/09/17/182/</id>
    <published>2016-09-17T14:38:08.000Z</published>
    <updated>2016-09-29T01:25:57.762Z</updated>
    
    <content type="html"><![CDATA[<p>要想使用stl配接器算法，unary_function、binary_function的仿函数就必须使用.</p>
<h3 id="先来看STL已经提供的仿函数"><a href="#先来看STL已经提供的仿函数" class="headerlink" title="先来看STL已经提供的仿函数"></a>先来看STL已经提供的仿函数</h3><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><h4 id="算法类仿函数"><a href="#算法类仿函数" class="headerlink" title="算法类仿函数"></a>算法类仿函数</h4><p>加法： <code>plus&lt;T&gt;</code> <br><br>减法：<code>minus&lt;T&gt;</code><br><br>乘法：<code>multiplies&lt;T&gt;</code><br><br>除法：<code>divides&lt;T&gt;</code> <br><br>模取：<code>modulus&lt;T&gt;</code><br><br>否定：<code>negate&lt;T&gt;</code>(一元)<br></p>
<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p>等于：<code>equal_to&lt;T&gt;</code><br><br>不等于：<code>not_equal_to&lt;T&gt;</code><br><br>大于：<code>greater&lt;T&gt;</code><br><br>大于或等于：<code>greater_equal&lt;T&gt;</code><br><br>小于：<code>less&lt;T&gt;</code><br><br>小于或等于:<code>less_equal&lt;T&gt;</code><br></p>
<h4 id="逻辑运算仿函数"><a href="#逻辑运算仿函数" class="headerlink" title="逻辑运算仿函数"></a>逻辑运算仿函数</h4><p>and: <code>logical_and&lt;T&gt;</code><br><br>or: <code>logical_or&lt;T&gt;</code><br><br>not: <code>logical_not&lt;T&gt;</code><br></p>
<h4 id="选择和投射"><a href="#选择和投射" class="headerlink" title="选择和投射"></a>选择和投射</h4><p><code>select1st&lt;T&gt;</code> <code>select2nd&lt;T&gt;</code> 对于此类，是针对pair的，传入pair，并返回第一个元素或第二个元素<br><br><code>project1st&lt;T&gt;</code> <code>project2nd&lt;T&gt;</code> 对于此类，是针对多参数的，传入俩个参数，只返回第一个元素或第二个元素<br></p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><h3 id="再看配接器"><a href="#再看配接器" class="headerlink" title="再看配接器"></a>再看配接器</h3><table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:center">实际效果</th>
<th style="text-align:center">实际对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#bind">bind(_Farg0::* const _Pmd, _Arg0&amp;&amp; _A0)</a></td>
<td style="text-align:center">11的新特性，auto配合万能绑定，参数能支持到20个参数，对成员函数绑定时第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#bind1st">bind1st(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(x, param)</td>
<td style="text-align:center">binder1st<op>(op, arg1_type(x))</op></td>
</tr>
<tr>
<td><a href="#bind2nd">bind2nd(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(param, x)</td>
<td style="text-align:center">binder2nd<op>(op, arg2_type(x))</op></td>
</tr>
<tr>
<td><a href="#not1">not1(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param)</td>
<td style="text-align:center">unary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#not2">not2(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param1, param2)</td>
<td style="text-align:center">binary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#compose1">compose1(const Op1&amp; op1, const Op2&amp; op2)</a></td>
<td style="text-align:center">op1(op2(param))</td>
<td style="text-align:center">unary_compose<op1, op2="">(op1, op2)</op1,></td>
</tr>
<tr>
<td><a href="#compose2">compose2(<br>const Op1&amp; op1,<br> const Op2&amp; op2,<br> const Op3&amp; op3)</a></td>
<td style="text-align:center">op1(op2(param),<br> op3(param))</td>
<td style="text-align:center">binary_compose<op1, op2,="" op3=""><br>(op1, op2, op3)</op1,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg))</a></td>
<td style="text-align:center">fp(param)</td>
<td style="text-align:center">pointer_to_unary_function<arg, result="">(fp)</arg,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg1, Arg2))</a></td>
<td style="text-align:center">fp(param1, param2)</td>
<td style="text-align:center">pointer_to_binary_function<arg1, arg2,="" result="">(fp)</arg1,></td>
</tr>
<tr>
<td><a href="#mem_fn">mem_fn()</a></td>
<td style="text-align:center">11的新特性，auto配合，和bind绑定成员函数块差别不大，第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)())</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)() const)</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">const_mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)())</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)() const)</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">const_mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A))</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">const_mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A))</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">const_mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
</tbody>
</table>
<hr>
<p></p><h2 id="bind"> bind <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyPair &#123;</div><div class="line"><span class="keyword">double</span> a,b;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a*b;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Foo &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">//这里注意 adds visibility of _1, _2, _3,...</span></div><div class="line"></div><div class="line"><span class="comment">// binding functions:</span></div><div class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,<span class="number">_1</span>,<span class="number">2</span>);               <span class="comment">// returns x/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind (my_divide,<span class="number">_2</span>,<span class="number">_1</span>);            <span class="comment">// returns y/x</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt; (my_divide,<span class="number">_1</span>,<span class="number">_2</span>);     <span class="comment">// returns int(x/y)</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></div><div class="line"></div><div class="line">MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// binding members:</span></div><div class="line"><span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind (&amp;MyPair::multiply,<span class="number">_1</span>); <span class="comment">// returns x.multiply()</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>; </div><div class="line"></div><div class="line">Foo foo;</div><div class="line"><span class="keyword">auto</span> f3 = <span class="built_in">std</span>::bind(&amp;Foo::print_sum, foo, <span class="number">95</span>, <span class="number">_1</span>);</div><div class="line">f3(<span class="number">5</span>);</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="bind1st"> bind1st <h2><p></p>
<p></p><h2 id="bind2nd"> bind2nd <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a - b &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    for_each(a, a+<span class="number">4</span>, bind1st(ptr_fun(fun), <span class="number">2</span>));<span class="comment">//此处由于，bind1st要传入适配器，所以要么fun继承前面的多元函数，要么如此处理</span></div><div class="line">    for_each(a, a+<span class="number">4</span>, bind2nd(ptr_fun(fun), <span class="number">2</span>));</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not1"> not1 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">count_if(a, a+<span class="number">5</span>, not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">4</span>)))<span class="comment">//统计大于等于4的个数</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not2"> not2 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> h = accumulate(a, a+<span class="number">5</span>, <span class="number">4</span>, not2(ptr_fun(fun)));<span class="comment">//此中的not2然并卵作用，主要是自己无法想到好的二元算法了</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="compose1"> compose1 <h2><p></p>
<p></p><h2 id="compose2"> compose2 <h2><br><figure class="highlight c"><figcaption><span>它是GNU的所以vs STL没有，有源码如下++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1, <span class="keyword">class</span> <span class="number">_F</span>n2&gt;</div><div class="line"><span class="keyword">class</span> unary_compose</div><div class="line">    : <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt;</div><div class="line">&#123;    <span class="comment">// functor adapter _Func(stored, right)</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt; <span class="number">_B</span>ase;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::argument_type argument_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::result_type result_type;</div><div class="line"></div><div class="line">    unary_compose(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1,</div><div class="line">        <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">        : op1(<span class="number">_F</span>unc1), op2(<span class="number">_F</span>unc2)</div><div class="line">        &#123;    <span class="comment">// construct from functor and left operand</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="number">_F</span>n1 op1;    <span class="comment">// the functor to apply</span></div><div class="line">    <span class="number">_F</span>n2 op2;    <span class="comment">// the functor to apply</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1,</div><div class="line"><span class="keyword">class</span> <span class="number">_F</span>n2&gt; <span class="keyword">inline</span></div><div class="line">unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt; compose1(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1, <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">&#123;    <span class="comment">// return a unary_compose functor adapter</span></div><div class="line">    <span class="keyword">return</span> (unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt;(<span class="number">_F</span>unc1, <span class="number">_F</span>unc2));</div><div class="line">&#125;</div><div class="line"></div><div class="line">for_each(a, a+<span class="number">5</span>, compose1(bind2nd(multiplies&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>), bind2nd(plus&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>))); </div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="ptr_fun"> ptr_fun <h2><p></p>
<blockquote>
<p>上面已经有代码演示，无需</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fun"> mem_fun <h2><br><figure class="highlight c"><figcaption><span>成员对象必须是指针++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>*&gt; numbers;</div><div class="line"></div><div class="line"><span class="comment">// populate vector of pointers:</span></div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"one"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"two"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"three"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"four"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"five"</span>) );</div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lengths ( numbers.size() );</div><div class="line"></div><div class="line">transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;<span class="built_in">string</span>::length));</div><div class="line">    </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *numbers[i] &lt;&lt; <span class="string">" has "</span> &lt;&lt; lengths[i] &lt;&lt; <span class="string">" letters.\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// deallocate strings:</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;::iterator it = numbers.begin(); it!=numbers.end(); ++it)</div><div class="line">    <span class="keyword">delete</span> *it;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="mem_fun1"> mem_fun1 <h2><p></p>
<blockquote>
<p>这个函数并不像<code>实际效果</code>那样，它应该是俩个参数，且各个绑定不同。<br>此函数11之后被淘汰</p>
</blockquote>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> dd &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       dd() &#123;&#125;</div><div class="line">       ~dd() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">aa</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; a - <span class="number">1</span>  &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind2nd(mem_fun1(&amp;dd::aa), <span class="number">2</span>));<span class="comment">//如此便是循环执行：iterator-&gt;aa(2);</span></div><div class="line"></div><div class="line">   <span class="comment">////////////////////////////</span></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> aa &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       aa() &#123;&#125;</div><div class="line">       ~aa() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">dd</span><span class="params">(dd* a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">33</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   aa s;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind1st(mem_fun1(&amp;aa::dd), &amp;s));<span class="comment">//如此便是循环执行：(&amp;s)-&gt;dd(iterator);</span></div><div class="line"></div></pre></td></tr></table></figure>
<hr>
<p></p><h2 id="mem_fun_ref"> mem_fun_ref <h2><p></p>
<p></p><h2 id="mem_fun1_ref"> mem_fun1_ref <h2><p></p>
<blockquote>
<p>它们和<code>mem_fun</code>区别在于，iterator是对象，而不是指针。<br>mem_fun1_ref此函数11之后被淘汰</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fn"> mem_fn <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   dd a;</div><div class="line"><span class="keyword">auto</span> triple = <span class="built_in">std</span>::mem_fn(&amp;dd::aa);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; triple(a, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以a为调用对象，传入2</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
</h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要想使用stl配接器算法，unary_function、binary_function的仿函数就必须使用.&lt;/p&gt;
&lt;h3 id=&quot;先来看STL已经提供的仿函数&quot;&gt;&lt;a href=&quot;#先来看STL已经提供的仿函数&quot; class=&quot;headerlink&quot; title=&quot;先来看
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c函数" scheme="https://xuecat.github.io/tags/c%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>MP3解码过程小知识181</title>
    <link href="https://xuecat.github.io/2016/09/08/181/"/>
    <id>https://xuecat.github.io/2016/09/08/181/</id>
    <published>2016-09-08T13:27:43.000Z</published>
    <updated>2016-10-02T01:28:18.754Z</updated>
    
    <content type="html"><![CDATA[<p>代码暂时不提供了，直接去<code>178</code>的sobey库寻。说明MP3音频过程遇见。</p>
<ol>
<li>帧头是大端字节，所以要转换下</li>
<li>判断是否是帧头，看第一个字节是否是FF，同步信息第一个字节必须是FF（qq音乐喜欢用ff fe，网络音乐喜欢用ff fb）</li>
<li>vbr的xing头并不影响解码，照常使用，只是在标签帧中多些信息而已</li>
<li>有些MP3没有TAG ID3V2头只有ID3V1头，文件起点直接开始第一帧帧头，数据。。。</li>
<li><p>有些MP3的TAG ID3V2头算出来的大小不准确，并不能找到第一帧位置。<br>这时，多半是它在第一帧和标签头之间又填充了很多无用信息<br>此时只能一个个字节去找FF帧头了</p>
</li>
<li><p>MP3标签帧对图片有保存：<a href="http://blog.csdn.net/studywithallofyou/article/details/7738785" target="_blank" rel="external">http://blog.csdn.net/studywithallofyou/article/details/7738785</a>  但是我在用ue去解析qq的MP3文件，却发现无APIC，虽没用代码检测，<code>先标记吧</code></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码暂时不提供了，直接去&lt;code&gt;178&lt;/code&gt;的sobey库寻。说明MP3音频过程遇见。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帧头是大端字节，所以要转换下&lt;/li&gt;
&lt;li&gt;判断是否是帧头，看第一个字节是否是FF，同步信息第一个字节必须是FF（qq音乐喜欢用ff fe，网络
    
    </summary>
    
      <category term="音视频" scheme="https://xuecat.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>180</title>
    <link href="https://xuecat.github.io/2016/09/08/180/"/>
    <id>https://xuecat.github.io/2016/09/08/180/</id>
    <published>2016-09-08T13:25:50.000Z</published>
    <updated>2016-09-10T01:32:27.976Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><h5 id="“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”"><a href="#“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”" class="headerlink" title="“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”"></a>“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”</h5></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;h5 id=&quot;“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”&quot;&gt;&lt;a href=&quot;#“梦里相逢人不见，若知是梦何须醒。纵然梦里常幽会，怎比真如见一回。”&quot; class=&quot;heade
    
    </summary>
    
      <category term="生活" scheme="https://xuecat.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="life" scheme="https://xuecat.github.io/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>bmp的颜色存储179</title>
    <link href="https://xuecat.github.io/2016/09/06/179/"/>
    <id>https://xuecat.github.io/2016/09/06/179/</id>
    <published>2016-09-05T16:11:51.000Z</published>
    <updated>2016-09-08T13:11:31.360Z</updated>
    
    <content type="html"><![CDATA[<p><strong>BGR与Bit-Fields</strong><br>当图像中引用的色彩超过256种时，我们就需要16bpp或更高bpp的位图。调色板不适合bpp较大的位图，因此16bpp以上的位图都不使用调 色板。<br>不使用调色板的位图图像有两种编码格式：RGB和Bit-Fields（下称BF）。<br></p>
<p>RGB编码格式是一种均分的思想，使Red、Green、Blue三个颜色分量所包含的信息容量尽可能一样大。<br>16bpp-RGB：在每个像素所占的16bits中，低5位表示Blue分量；中5为表示Green分量；高5位表示Red分量；最高1位无意义 （后来有些应用程序将其视为透明度Alpha分量，但这并不是标准）。<br>所以从低到高的顺序实际上是B-G-R，这也是我在BMP简介的表格里，把RGB的 编码方式都写成BGR的原因。<br><br>24bpp-RGB：24bpp的位图又称为真彩位图，它通常只有这一种编码格式，在24bits中，低8位表示Blue分量；中8为表示 Green分量；高8位表示Red分量。BGR<br><br>32bpp-RGB：在32bits中，低24位的编码方式与24bpp位图相同，最高8位用来表示透明度Alpha分量。<br>32bpp的位图尺寸太 大，一般只有在图像处理的中间过程中使用。对于需要半透过效果的图像，更好的选择是PNG格式。<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;BGR与Bit-Fields&lt;/strong&gt;&lt;br&gt;当图像中引用的色彩超过256种时，我们就需要16bpp或更高bpp的位图。调色板不适合bpp较大的位图，因此16bpp以上的位图都不使用调 色板。&lt;br&gt;不使用调色板的位图图像有两种编码格式：RGB和Bi
    
    </summary>
    
      <category term="音视频" scheme="https://xuecat.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
