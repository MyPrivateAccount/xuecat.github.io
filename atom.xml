<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XueCat</title>
  <subtitle>用代码创造世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuecat.github.io/"/>
  <updated>2016-12-01T13:26:51.130Z</updated>
  <id>https://xuecat.github.io/</id>
  
  <author>
    <name>XueCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c#空字符和无字符201</title>
    <link href="https://xuecat.github.io/2016/12/01/201/"/>
    <id>https://xuecat.github.io/2016/12/01/201/</id>
    <published>2016-12-01T13:24:56.000Z</published>
    <updated>2016-12-01T13:26:51.130Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> str1=stirng.Empty;</div><div class="line"><span class="built_in">string</span> str2=<span class="string">""</span>;</div><div class="line"><span class="built_in">string</span> str3=null;</div></pre></td></tr></table></figure>
<p>str1和str2暂时可视为无区别，但建议多str1<br>str3是空指针，堆上没有开辟内存的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>windbg调试200</title>
    <link href="https://xuecat.github.io/2016/12/01/200/"/>
    <id>https://xuecat.github.io/2016/12/01/200/</id>
    <published>2016-12-01T13:05:20.000Z</published>
    <updated>2016-12-01T14:29:24.792Z</updated>
    
    <content type="html"><![CDATA[<p>产生dump：<a href="https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump" target="_blank" rel="external">https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump</a></p>
<p>debug工具一般都有debugger.chm这个文档可以参考<br>x64:</p>
<ol>
<li>拖拽到windbg，lm查看模块状态</li>
<li>查看时间戳(lmt)，找到对应pdb，设置pdb路径</li>
<li>重新加载pdb(.reload)，运行分析命令(!analyze -v)<br>一般崩溃会有exception，就查找这个字符串，就可以找到对应执行函数。(~N 切换到N号线程，主线程是0号)<br>主线程没有就切换到其它线程查找(~*e kb)</li>
</ol>
<p>x32:<br>基本相同，但是当32位程序运行在64位系统的时候，产生的dump</p>
<ol>
<li>先加载64位的扩展(.load wow64exts)</li>
<li>切换到32位模式(!sw)</li>
<li>然后才再像上面那样调试</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;产生dump：&lt;a href=&quot;https://social.technet.microsoft.com/Forums/scriptcenter/zh-CN/e79d38d9-7360-41e5-8288-24f978877755/dump&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>VA_snippets199</title>
    <link href="https://xuecat.github.io/2016/11/29/199/"/>
    <id>https://xuecat.github.io/2016/11/29/199/</id>
    <published>2016-11-29T15:17:33.000Z</published>
    <updated>2016-11-29T16:03:05.058Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">Aline</div><div class="line">//////////////////////////////////////////////////////////////////////////</div><div class="line"></div><div class="line">big moudle</div><div class="line">/************************************************************************/</div><div class="line">/* $end$                                                                     */</div><div class="line">/************************************************************************/</div><div class="line"></div><div class="line">brief</div><div class="line">/*</div><div class="line"> * @brief $end$</div><div class="line"> */</div><div class="line"></div><div class="line">enum</div><div class="line"> /**&lt; $end$ */</div><div class="line"></div><div class="line">member</div><div class="line"> /**&lt; @brief $end$,  */</div><div class="line"></div><div class="line"> function</div><div class="line"> /** </div><div class="line"> * @param [in]</div><div class="line"> * @param [out]</div><div class="line"> * @return</div><div class="line"> * @brief $end$</div><div class="line"> * @note</div><div class="line"> */</div><div class="line"></div><div class="line"> Time</div><div class="line"> // $end$ [$MONTH$/$DAY$/$YEAR$ %USERNAME%]</div><div class="line"></div><div class="line">Doxygen - Class Comment</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Class Comment (Long)</div><div class="line">/*!</div><div class="line"> * @class $classname$</div><div class="line"> * @ingroup GroupName</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note </div><div class="line"> * @author %USERNAME%</div><div class="line"> * @version 1.0</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> */</div><div class="line"></div><div class="line"> Doxygen - Header Comment</div><div class="line"> /*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * @date $MONTHLONGNAME$ $YEAR$</div><div class="line"> *</div><div class="line"> * $end$</div><div class="line"> */</div><div class="line"></div><div class="line">Doxygen - Header Comment (Long)</div><div class="line">/*!</div><div class="line"> * @file $FILE_BASE$.$FILE_EXT$</div><div class="line"> * @date $DATE$ $HOUR$:$MINUTE$</div><div class="line"> *</div><div class="line"> * @author %USERNAME%</div><div class="line"> * Contact: user@company.com</div><div class="line"> *</div><div class="line"> * @brief $end$</div><div class="line"> *</div><div class="line"> * TODO: long description</div><div class="line"> *</div><div class="line"> * @note</div><div class="line">*/</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>多线程198</title>
    <link href="https://xuecat.github.io/2016/11/21/198/"/>
    <id>https://xuecat.github.io/2016/11/21/198/</id>
    <published>2016-11-21T15:22:33.000Z</published>
    <updated>2016-11-26T07:16:03.812Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/t1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>咋说呢，一直以来虽然知道<code>_beginthreadex</code>比较好。但是想起55用<code>CreateThread</code>，还是有点余悸。</p>
<p><strong>先看段原话</strong>：</p>
<p>有些CRT的函数象<code>malloc(), fopen(), _open(), strtok(), ctime(), 或localtime()</code>等函数需要专门的线程局部存储的数据块，<br>这个数据块通常需要在创建线程的时候就建立，如果使用<code>CreateThread</code>，这个数据块就没有建立，然后会怎样呢？<br>在这样的线程中还是可以使用这些函数而且没有出错，实际上函数发现这个数据块的指针为空时，会自己建立一个，<br>然后将其与线程联系在一起，这意味着如果你用<code>CreateThread</code>来创建线程，然后使用这样的函数，<br>会有一块内存在不知不觉中创建，遗憾的是，这些函数并不将其删除，而<code>CreateThread</code>和<code>ExitThread</code>也无法知道这件事，<br>于是就会有Memory Leak，在线程频繁启动的软件中(比如某些服务器软件)，迟早会让系统的内存资源耗尽！<br></p>
<hr>
<p><strong>说白了</strong>：如果多线程里面有CRT函数，最好使用<code>_beginthread</code>   <code>_beginthreadex</code>   <code>AfxBeginThread</code>(这个函数内部调用<code>_beginthreadex</code>创建处理的<code>CWinThread</code>专门的UI线程，可以通过发送接收message)</p>
<p>上面四个线程都有相应的<code>ExitThread或_endthread</code>；当然这些函数必须放入线程函数中。<br></p>
<h4 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h4><h4 id="共同的毛病1："><a href="#共同的毛病1：" class="headerlink" title="共同的毛病1："></a>共同的毛病1：</h4><p><strong>虽然</strong>：在线程被创建成功后，都可以用<code>WaitForSingleObject( hThread, INFINITE );</code>来等待线程结束。<br><strong>但是这是不准的</strong>：一些<code>begin</code>函数本身就有<code>CloseHandle</code>了（如：<code>_beginthread</code>），再加上一些代码的<code>CloseHandle</code>，<br>所以无法正确知道线程的计数到底是在哪个时候被置为0，而且被置为0也不一定会是线程退出。<br>再说执行完线程函数后，<code>beging</code>函数本身有许多代码要执行。<br><strong>也就是说，最好不要这么等待线程结束，最好给个事件、原子等放在线程函数末尾，来判断线程是否结束。</strong></p>
<h4 id="共同的毛病2："><a href="#共同的毛病2：" class="headerlink" title="共同的毛病2："></a>共同的毛病2：</h4><p>如果在线程函数中调用退出函数，是会立即退出的。<br>也就是说连执行线程函数中，定义类的析构函数都来不及，就会直接退出线程返回，<br>如果那个类有析构有内存释放的话就糟糕了，会出现内存泄漏的。<br><strong>也就是说，最好不要用退出线程函数来退出线程，用return自然返回是最好的。</strong></p>
<h4 id="内存释放："><a href="#内存释放：" class="headerlink" title="内存释放："></a>内存释放：</h4><ul>
<li>内存释放这里也有个共同点； 创建线程后直接<code>CloseHandle</code>是可以的，这样的线程对象，在函数运行完了就自动释放（就算是_beginthread等有自释放代码的类型也同样适用）</li>
</ul>
<p><code>AfxBeginThread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthread</code>会自动<code>CloseHandle</code>；相应<code>endthread</code>函数也有<code>CloseHandle</code>代码<br><code>_beginthreadex</code>必须手动<code>CloseHandle</code><br><code>CreateThread</code>必须手动<code>CloseHandle</code></p>
<h4 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h4><p><code>AfxBeginThread</code>创建的线程比较庞大，一般的后台运行线程是没必要的<br><code>CreateThread</code>创建的线程无法使用CRT函数<br><code>_beginthread</code>创建的线程可以使用CRT函数，但引用官方的话来说：“使用 _beginthreadex 比 _beginthread 更为安全”；</p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="c函数" scheme="https://xuecat.github.io/tags/c%E5%87%BD%E6%95%B0/"/>
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="多线程" scheme="https://xuecat.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>c#入门经典197</title>
    <link href="https://xuecat.github.io/2016/11/21/197/"/>
    <id>https://xuecat.github.io/2016/11/21/197/</id>
    <published>2016-11-21T13:39:27.000Z</published>
    <updated>2016-12-01T15:40:37.285Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/r4.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<p>唉！！，es6正看着呢；去海外组了。。。。要补c#知识了</p>
<h3 id="NET程序："><a href="#NET程序：" class="headerlink" title=".NET程序："></a>.NET程序：</h3><p>使用.NET兼容语言（如c#）编写程序 -&gt; 把代码编译为CIL，存储在程序集中（即VS干的事） <br><br>-&gt; 执行时，先使用JIT编译器将代码编译为本机代码 -&gt; 在托管的CLR环境下运行本机代码。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h4><p>字节数增多：sbyte(1) short(2) int(4) long(8)<br>不同的是：其它类型的<code>unsigned</code>前面加<code>u</code>就好，唯独<code>byte</code>是0到255</p>
<p>转义字符(\”表示”)和字面量(100L 100F)都和c++差不多<br>多了个新功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> strTest = <span class="string">"wangqiu"</span>;</div><div class="line"><span class="built_in">string</span> strHEHE = $<span class="string">"&#123;strTest&#125; hehe"</span> + $<span class="string">" &#123;3+5&#125;de"</span>;<span class="comment">//这样是可以的哟，用法如同js的模板字符</span></div></pre></td></tr></table></figure>
<p><strong>差点忘了说，c#中变量类型其实全是System的类，也就意味着基本变量类型本身就有很多成员函数可以使用</strong></p>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p><code>switch</code>语句有点不同，多了个<code>goto case &lt;com&gt;:</code>，用来实现在这个case语句中跳转到其它case语句中</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>用法基本同；c#多了层保险，可以用<code>checked((type))</code>出现的崩溃来保证，高字节向低字节转换;也可以默认设置强制转换加check；在书67页。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>用法和c++基本同；多了个指定类型，<code>enum Type : long</code>，这样指定枚举变量的类型。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] myArray = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//很智能，可以自动创建数组类，这样就能使用很多成员函数了。</span></div><div class="line"><span class="keyword">int</span>[] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>] &#123;<span class="number">6</span>, <span class="number">7</span>&#125;;<span class="comment">//new int[number],不能new int;</span></div></pre></td></tr></table></figure>
<p>数组的遍历可以用<code>for</code>也可以用<code>foreach(string f in fN)</code>;只是<code>foreach</code>里的f是只读属性，不能写。</p>
<ul>
<li>多元数组</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//几元数组就用几个`,`表示</span></div><div class="line"><span class="keyword">int</span>[,] h = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">int</span>[,] s = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;<span class="comment">//但是这种赋值会改变，声明的几元</span></div><div class="line"><span class="comment">//foreach会一行一行遍历全部元素。</span></div></pre></td></tr></table></figure>
<ul>
<li>锯齿数组<br>这个更该是数组中的数组，一个行不一定固定个数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [][] d = &#123;</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>&#125;,<span class="comment">//这行就一个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,<span class="comment">//这行俩个</span></div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</div><div class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">8</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p><code>var</code>会自动转换到相应的类型，当然也可以访问相应的成员函数。</p>
<h4 id="as和is"><a href="#as和is" class="headerlink" title="as和is"></a>as和is</h4><p>is会做俩次检查，as会做一次检查，as效率会高点<br>as类似于强制转换，转换失败便返回null<br>as只能用于引用类型和装箱转换，所以值类型还是得用is</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>类中函数默认是private类型的，如果访问要public<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数组参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">int</span>[] intA</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//引用参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">ref</span> <span class="keyword">int</span> val</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">ref</span> intA);<span class="comment">//它调用也比较特殊，还有就是intA必须要被赋过值</span></div><div class="line"></div><div class="line"><span class="comment">//输出参数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span>(<span class="params"><span class="keyword">out</span> <span class="keyword">int</span> valA</span>) </span>&#123;&#125;</div><div class="line">Show(<span class="keyword">out</span> intA)<span class="comment">//感觉它比引用都高级</span></div></pre></td></tr></table></figure></p>
<p>函数可以重载，但是<code>out</code>和<code>ref</code>不能相同</p>
<ul>
<li>c#支持lambda<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetI</span><span class="params">()</span> </span>=&gt; <span class="number">1</span> + <span class="number">3</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><ol>
<li>支持默认参数，同时不会在意默认参数位置（即不像c++那样默认参数必须放后面）</li>
<li>支持无序传入，<code>SName(kk:1, hh:2)</code>这种形式传入是支持的，但是如果这样写就必须把所有参数写完。</li>
</ol>
<h4 id="c-的委托像c-的函数指针"><a href="#c-的委托像c-的函数指针" class="headerlink" title="c#的委托像c++的函数指针"></a>c#的委托像c++的函数指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">Run</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span> </span>&#123;&#125;</div><div class="line"><span class="function">delegate <span class="keyword">double</span> <span class="title">Process</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span></span>;</div><div class="line">Process tp1 = Run;</div><div class="line">Process tp2 = (<span class="keyword">int</span> p1, <span class="keyword">int</span> p2) =&gt; &#123;<span class="keyword">return</span> p1 + p2;&#125;;</div><div class="line">Process tp3 = <span class="keyword">new</span> Process(Run);<span class="comment">//标准建议这种写法，说是能</span></div><div class="line">明白干了什么</div></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><ol>
<li><p>带运算；<br><code>Console.WriteLine($&quot;{SName(1, 2)}&quot;)</code>;会运算了SName函数再输出；注意的是它和参数传入形式不能共存。</p>
</li>
<li><p>参数传入；<br><code>Console.WriteLine(&quot;{0}a{1}&quot;, 10.02, 121);</code>这里<code>0</code>表示后面第一个参数，随着参数增加，可以依次递增。<br>还有，它会完整输出参数的形式。不用担心是string、int、float，它全按参数形式输出。</p>
</li>
<li><p>格式符；<br>只记录几个简单的：<br>D 十进制、N数字格式、X十六进制、P百分数格式；<br><code>Console.WriteLine(String.Format(&quot;{0:N1}&quot;, 10))</code>这里{0:N1}表示第一个参数，按数字格式输出，小数点后留一位。<br>格式符后面的数字可增加，表示小数点后面的位数。但是格式符前面不能加数字，实在加要用占位符。</p>
</li>
<li><p>占位符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:0000.00&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">0194.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:###.##&#125;"</span>, <span class="number">12394.039</span>) 结果为：<span class="number">12394.04</span></div><div class="line"><span class="built_in">string</span>.Format(<span class="string">"&#123;0:####.#&#125;"</span>, <span class="number">194.039</span>) 结果为：<span class="number">194</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>零占位符：<br>如果格式化的值在格式字符串中出现“0”的位置有一个数字，则此数字被复制到结果字符串中。小数点前最左边的“0”的位置和小数点后最右边的“0”的位置确定总在结果字符串中出现的数字范围。<br>“00”说明符使得值被舍入到小数点前最近的数字，其中零位总被舍去。<br>数字占位符：<br>如果格式化的值在格式字符串中出现“#”的位置有一个数字，则此数字被复制到结果字符串中。否则，结果字符串中的此位置不存储任何值。<br>请注意，如果“0”不是有效数字，此说明符永不显示“0”字符，即使“0”是字符串中唯一的数字。如果“0”是所显示的数字中的有效数字，则显示“0”字符。<br>“##”格式字符串使得值被舍入到小数点前最近的数字，其中零总被舍去。</p>
<p>但是占位符又不简单的是这些：<code>(&quot;{0:123##2.00}&quot;, 11)</code>输出：123112.00 <code>(&quot;{0:123##20.00}&quot;, 11)</code>输出：123121.00<br>看来实际用还得再测试下。</p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>调试信息的输出，这个调试信息是输出一行，比c++方便多了。<br><code>Debug.WriteLine()</code>只能在debug模式下<br><code>Trace.WriteLine()</code>任何模式下<br><code>Debug.Assert()</code><br><code>Trace.Assert()</code></p>
<p>也支持<code>try catch finally</code> finally必执行。</p>
<h4 id="XML文档"><a href="#XML文档" class="headerlink" title="XML文档"></a>XML文档</h4><p>这个我觉得很有必要。c++一般都是doxygen语法来，c#却这么高级直接官方支持（官方的snippets简直丧心病狂，太好用了）。<br>另外官方建议用<code>Sandcastle</code>来生成相关阅读文档。</p>
<p>值列举常用的，详细：<a href="http://www.cnblogs.com/mq0036/p/3544264.html" target="_blank" rel="external">http://www.cnblogs.com/mq0036/p/3544264.html</a><br>summary：永远描述类型<br>remarks：添加有关类型的信息，补充summary<br>param：参数描述<br>returns：返回值描述<br>value: 属性说明（官方示例是set、get的那些属性）<br>example：示例代码部分<br>c：文本标记为代码<br>code：多行指示为代码<br>exception：异常说明<br>see：seealso：用<code>&lt;see cref=&quot;member&quot;/&gt;</code></p>
<h4 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> #<span class="meta-keyword">undef</span> #<span class="meta-keyword">if</span> #<span class="meta-keyword">elif</span> #<span class="meta-keyword">else</span> #<span class="meta-keyword">endif</span> <span class="comment">//和c++相同</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG </span></div><div class="line">    <span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"Don't"</span><span class="comment">//c#的警告和错误的预编译和c++不同</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Wrong"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#region #endregion<span class="comment">//折叠用</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span><span class="comment">//此指令和c++使用完全不同</span></span></div></pre></td></tr></table></figure>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a>this和base</h4><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">internal <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//此关键字修饰的类，只运行同一个程序集访问（即同一exe或dll）</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> My&#123;&#125;;<span class="comment">//运行其它程序集访问</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//也可以加private等，此修饰符是抽象类，只能继承，不能实例化</span></div><div class="line"><span class="keyword">public</span> sealed <span class="keyword">class</span> M&#123;&#125;;<span class="comment">//此修饰符不允许继承</span></div><div class="line"></div><div class="line"><span class="comment">//继承的时候要注意：编译器不允许派生类的可访性高于基类，即内部类继承公共类可以，公共类继承内部不行。</span></div><div class="line"><span class="comment">//以下不行：</span></div><div class="line">internal <span class="keyword">class</span> My&#123;&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MD : My&#123;&#125;<span class="comment">//不行</span></div><div class="line"></div><div class="line"><span class="comment">//继承时不能有多个基类，c#只运行一个基类；但是可以加接口的</span></div><div class="line"><span class="keyword">class</span> My : MyBass, IMyInterface, IMy&#123;&#125; <span class="comment">//虽然只能一个基类，但是多个接口是可以的。注意接口必须在基类后面</span></div></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>大量例子对属性的使用都是这样的，感觉这个属性有点多余。<br>属性支持访问控制：<code>get</code>和<code>set</code>支持使用：public、private、protected来控制访问。<br>属性支持重写：<code>abstract</code>、<code>virtual</code>、<code>override</code>这些可以联合使用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="number">_</span>age;</div><div class="line"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">int</span> Age &#123;</div><div class="line">    get &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">_</span>age;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">set</span> &#123;</div><div class="line">        <span class="number">_</span>age = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自动属性<code>public double Height { get; set; }</code></p>
<h4 id="构造函数和析构"><a href="#构造函数和析构" class="headerlink" title="构造函数和析构"></a>构造函数和析构</h4><p>基本和c++相同，允许重载、访问控制。<br>不同：</p>
<ul>
<li>执行顺序（MyDericed继承基类）；MyDericed myO = new MyDericed();1、执行System.Object.Object()构造函数；2、执行MyBaseClass.MyBaseClass构造函数；3、执行MyDericed构造函数</li>
<li>委托不同；<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class MyD: MyBass</div><div class="line">&#123;</div><div class="line">    public MyD() : this(5, 6)&#123;&#125;//委托给自身的另一个构造函数</div><div class="line">    public MyD(int i, int j) : base(i) &#123;&#125;//调用基类构造函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>##然后就是静态构造函数##<br>编写静态构造函数的一个原因是,类有一些静态字段或属性,需要在第一次使用类之前,从外部源中初始化这些静态字段和属性<br>由于并不确定它执行的时间，所以注意下此函数中对静态变量的赋值。</p>
<h4 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h4><p>给类加个static只是告诉编译器，这个类的所有成员必须是<code>static</code>类型的，不然就报错</p>
<h4 id="类和结构体区别"><a href="#类和结构体区别" class="headerlink" title="类和结构体区别"></a>类和结构体区别</h4><p>c#中类和结构体有个大大的区别， 类是引用类型，结构体是值类型。<br>也就是说：<br>直接的<code>=</code>操作对类来说是引用赋值（是浅拷贝过程）<br>直接的<code>=</code>操作对结构体来说是复制信息（是深拷贝）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MyStru st = <span class="keyword">new</span> MyStru&#123; d=<span class="number">1</span>, a=<span class="number">2</span> &#125;;<span class="comment">//值类型还是在栈空间</span></div></pre></td></tr></table></figure>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>被嵌套在里面的类可以访问外部类的private成员，这和c++不同</p>
<p>对于嵌套类则不能把类型定义为protectcd、private和protected internal,<br>因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。<br><strong>但是</strong>,如果是嵌套类的话，这些修饰符就有了些意义。</p>
<h4 id="其它定义字段"><a href="#其它定义字段" class="headerlink" title="其它定义字段"></a>其它定义字段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> readonly <span class="keyword">int</span> MyInt = <span class="number">3</span>;<span class="comment">//表示这个字段只能在执行构造函数的过程中赋值，或由初始化赋值语句赋值。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> MyInt;<span class="comment">//书上建议用const代替static，这样既避免出错也可以达到相同效果</span></div></pre></td></tr></table></figure>
<p>c#的extern导入的是外部程序集，经常和DllImport联合使用。</p>
<h4 id="继承使用"><a href="#继承使用" class="headerlink" title="继承使用"></a>继承使用</h4><p>c#的virtual、override、更是不同<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"My"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"You"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">class</span> HeClass : YouClass &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">ShowD</span><span class="params">()</span> </span>&#123;</div><div class="line">            Console.WriteLine(<span class="string">"He"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//可以看出，如果想要重写，必须用virtual、override的配合</span></div><div class="line">    <span class="comment">//如果是 override sealed void... 配合的话，重写就此结束；派生类不能再重写。</span></div></pre></td></tr></table></figure></p>
<h4 id="partial部分关键字的使用"><a href="#partial部分关键字的使用" class="headerlink" title="partial部分关键字的使用"></a>partial部分关键字的使用</h4><p>partial关键字允许把类、结构或接口放在多个文件中，编译再变成一个类。<br>包括继承对象也会整合在一起（但是访问权限关键字不能整合）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Big1.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter1</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="comment">//Big2.cs</span></div><div class="line">partial <span class="keyword">class</span> TheBig : IMyInter2</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//编译后就是</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> TheBig :IMyInter1, IMyInter2 </div><div class="line">&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//上面介绍了部分类，下面介绍部分方法</span></div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> partial <span class="keyword">class</span> MyClass</div><div class="line">&#123;</div><div class="line">    <span class="function">partial <span class="keyword">void</span> <span class="title">MyMethod</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//部分方法的出现是为了解决要使用其它部分类的方法时，避免访问不到。</span></div><div class="line"><span class="comment">//但是它有以下毛病：</span></div><div class="line"><span class="comment">//0、只能存在于partial的类中</span></div><div class="line"><span class="comment">//1、总是私有类型，且不能有返回值</span></div><div class="line"><span class="comment">//2、使用的任何参数不能是out参数。但ref参数是可以的</span></div><div class="line"><span class="comment">//3、不能使用virtual、abstract、overrride、new、sealed、extern这些修饰符</span></div></pre></td></tr></table></figure></p>
<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><p>浅拷贝由默认隐式转换和MemberwiseClone来完成不用说。<br>来看深拷贝代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> HeClass : ICloneable</div><div class="line">&#123;</div><div class="line">    HeClass(<span class="keyword">int</span> a)</div><div class="line">    &#123; <span class="number">_</span>me = a; &#125;</div><div class="line">    <span class="keyword">int</span> <span class="number">_</span>me;</div><div class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">Clone</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        HeClass c = <span class="keyword">new</span> HeClass(<span class="number">_</span>me);</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//发现必须继承ICloneable，并重写其函数</span></div><div class="line"><span class="comment">//还要注意new的构造函数传值问题。</span></div></pre></td></tr></table></figure></p>
<h4 id="重载符函数"><a href="#重载符函数" class="headerlink" title="重载符函数"></a>重载符函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> YouClass : MyClass &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> YouClass <span class="keyword">operator</span> +(YouClass a) &#123;</div><div class="line">        YouClass yy = <span class="keyword">new</span> YouClass();</div><div class="line">        <span class="keyword">return</span> yy;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ClassA a;</div><div class="line">classB b;</div><div class="line">ClassC c;</div><div class="line">c = a + b;</div><div class="line">像这样的参数就必须是(ClassA, classB)，更重要的和顺序有关。</div></pre></td></tr></table></figure>
<p>如上操作符函数有这些要求：<br>必须是public<br>必须是static<br>返回值必须是原型</p>
<p>一元运算符：+、-、！、~、++、–、true、false<br>二元：+、-、*、/、%、&amp;、|、^、&lt;&lt;、&gt;&gt;<br>比较：==、!=、&lt;、&gt;、&lt;=、&gt;=</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="函数隐藏"><a href="#函数隐藏" class="headerlink" title="函数隐藏"></a>函数隐藏</h4><p>c#会像c++那样出现函数隐藏，但是它面对函数隐藏的时候会报警告的,如果要消除警告：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDriver:</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">int</span> <span class="title">ShowD</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//加个new，这样做并不会改变执行时的代码调用；只是去掉编译的警告而已。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>所有类都派生于<code>System.Object</code>，即使定义时没指定基类也会默认继承。</p>
<h4 id="abstract和sealed"><a href="#abstract和sealed" class="headerlink" title="abstract和sealed"></a>abstract和sealed</h4><ul>
<li><code>abstract</code>对类；修饰并不能阻止其函数的定义，也无法使函数默认变成可重写类型(函数依旧需要自己声明重写类型)；<br>它对类来说就只能是个说明是接口类的作用，实际作用并没有。</li>
<li><code>abstract</code>对函数；此函数为虚函数，默认重写类型</li>
<li><code>sealed</code>对类；这样表示此类不能被继承</li>
<li><code>sealed</code>对函数；只能对可重写类型的函数才能使用（virtual abstract），表示此函数子类不能重写，常和<code>override</code>联合使用</li>
</ul>
<h4 id="拆箱和装箱"><a href="#拆箱和装箱" class="headerlink" title="拆箱和装箱"></a>拆箱和装箱</h4><p><strong>首先这俩个操作是隐式的</strong><br>所有值类型均隐式派生自System.ValueType：<br>结构体、数值、整形、字符（char）、浮点、bool、枚举、派生于System.Nullable<br>如<code>int i = new int()</code>等价于<code>int i = 0</code></p>
<p>所有引用类型均隐式派生自System.object(包括它本身)：<br>数组：（派生于System.Array）数组的元素，不管是引用类型还是值类型，都存储在托管堆上；<br>类：class（派生于System.Object）；<br>接口：interface（接口不是一个“东西”，所以不存在派生于何处的问题。）；<br>委托：delegate（派生于System.Delegate）；<br>object：（System.Object的别名）；<br>字符串：string（System.String的别名）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">object obj = <span class="number">1</span>;<span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>)obj;<span class="comment">//拆箱</span></div><div class="line"></div><div class="line"><span class="comment">//如上，c#中对值类型是放入栈中，对引用类型是放入堆中</span></div><div class="line"><span class="comment">//上面1是值，obj是引用。所以存在过程的转换</span></div><div class="line"><span class="comment">//这多余的转换会导致运行效率低下，所以请尽量避免。</span></div><div class="line"></div><div class="line"><span class="comment">//比如使用List&lt;obj&gt;来代替ArrayList;避免拆箱和装箱</span></div></pre></td></tr></table></figure>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>这个一般是yield return, yield break联合使用；如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; SName(<span class="keyword">int</span> a)</div><div class="line">&#123;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    yield <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">    yield <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//注意返回值必须是 IEnumerable 或 IEnumerator</span></div><div class="line"><span class="comment">//好像说这种方法比在函数里面push或add更有效</span></div></pre></td></tr></table></figure></p>
<h4 id="where约束"><a href="#where约束" class="headerlink" title="where约束"></a>where约束</h4><p>这个我不是很深，以后补充；先看段代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">class MyBase&lt;T&gt;</div><div class="line">    where T: class</div><div class="line">    , new() &#123;</div><div class="line">    public MyBase() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public MyBase(int n)</div><div class="line">        :this() &#123;</div><div class="line">        Console.WriteLine("base");</div><div class="line">    &#125;</div><div class="line">    public virtual T ShowD() &#123;</div><div class="line">        Console.WriteLine("MyBase");</div><div class="line">        T b = new T();//这里很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyDrive&lt;D&gt; : MyBase&lt;D&gt;, IEnumerable</div><div class="line">    where D: class, new() &#123;</div><div class="line">    public MyDrive()</div><div class="line">        : base(3) &#123;</div><div class="line">        Console.WriteLine("Drive");</div><div class="line">    &#125;</div><div class="line">    public MyDrive(int a)</div><div class="line">    &#123; &#125;</div><div class="line">    public override D ShowD() &#123;</div><div class="line">        Console.WriteLine("MyDrive");</div><div class="line">        D b = new D();//这句很重要</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyDrive&lt;Program&gt; my = new MyDrive&lt;Program&gt;(3);//调用</div></pre></td></tr></table></figure></p>
<p>第一个类；where对T约束为引用类型（值类型可以用struct），这样调用<code>&lt;&gt;</code>里面就只能是引用类型了<br>除此外where还约束为new()，表示<code>&lt;&gt;</code>里的类型必须有默认的构造函数，这样才可以用<code>new T()</code>这样的代码（测试发现里面不能加参数）</p>
<p>where还可以准确约束，有点像c++的模板特例化</p>
<h4 id="协变和抗变"><a href="#协变和抗变" class="headerlink" title="协变和抗变"></a>协变和抗变</h4><p><a href="http://blog.csdn.net/sudazf/article/details/17148971" target="_blank" rel="external">http://blog.csdn.net/sudazf/article/details/17148971</a></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> internal IMyInter&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Do</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂时看它和虚基类没啥区别呀！！！！！！以后再加吧。</p>
<h4 id="foreach的自定义"><a href="#foreach的自定义" class="headerlink" title="foreach的自定义"></a>foreach的自定义</h4><p>自定义类要使用foreach，就必须实现IEnumerator和IEnumerable<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyDrive : IEnumerable</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span><span class="params">()</span></span></div><div class="line">    &#123; <span class="keyword">return</span> <span class="keyword">new</span> MyTor(); &#125;</div><div class="line"></div><div class="line">    <span class="keyword">class</span> MyTor : IEnumerator</div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">MoveNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="keyword">public</span> object Current &#123; get &#123; <span class="keyword">return</span> null; &#125; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">MyDrive ss = <span class="keyword">new</span> MyDrive();</div><div class="line">foreach (var t in ss) &#123;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="C#" scheme="https://xuecat.github.io/categories/C/"/>
    
    
      <category term="编译器和VC" scheme="https://xuecat.github.io/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8CVC/"/>
    
  </entry>
  
  <entry>
    <title>ReactRouter-tutorial196</title>
    <link href="https://xuecat.github.io/2016/11/13/196/"/>
    <id>https://xuecat.github.io/2016/11/13/196/</id>
    <published>2016-11-13T02:16:25.000Z</published>
    <updated>2016-11-21T13:55:27.086Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu</a></p>
<ol>
<li>Router指定历史控件,切换路径历史直接：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">browserHistory.push(<span class="string">'/some/path'</span>);</div></pre></td></tr></table></figure>
<ol>
<li>Route来控制布局,path指定路径(path有匹配规则)，component指定控件。<br><code>&lt;Link to=&quot;/about&quot;&gt;</code> 被点击后，会激活to指定的相应路径，并渲染上面path指定的控件。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">            &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line">        &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//上面App包含了俩个，可以通过分别激活路径来切换显示区</div><div class="line"></div><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">    &lt;Route path="/repos" component=&#123;Repos&#125;&gt;</div><div class="line">        &lt;Route path="/repos/:repoName" component=&#123;Repo&#125;/&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">    &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div><div class="line">//三面三个同级，所以无论在哪个类里激活路径，都会跳转页面。</div><div class="line"></div><div class="line">//注意如果在App里面激活`/repos/:repoName`,则会先激活`/repos`再来激活它的子组件</div></pre></td></tr></table></figure>
<ol>
<li><p><code>&lt;IndexRoute component={Home}/&gt;</code> 设置默认渲染组件,如放上面1 - App下面，就会成为默认children渲染。<br> 如果想在列表有个组件相应的选中项 还要在App加个 <code>&lt;li&gt;&lt;NavLink to=&quot;/&quot; onlyActiveOnIndex={true}&gt;Home&lt;/NavLink&gt;&lt;/li&gt;</code></p>
</li>
<li><p>Contexts属性。</p>
</li>
</ol>
<ul>
<li>通过context传递属性的方式可以大量减少 通过显式的通过 props 逐层传递属性的方式。这样可以减少组件之间的直接依赖关系</li>
<li>如果你为一个组件指定了context，那么这个组件的子组件只要定义了contextTypes 属性，就可以访问到父组件指定的context了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">    &#125;,</div><div class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.withContext(&#123;<span class="string">'name'</span>: <span class="string">'Jonas'</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Outputs: "My name is: Jonas"</span></div><div class="line">    React.render(<span class="xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">/////////////////////////////////////////////////////////////////////////</div><div class="line">//父类可以指定contextTypes，也可以指定childContextTypes；childContextTypes只是限定了传给子类的类型,无它就默认全下传。</div><div class="line">var A = React.createClass(&#123;</div><div class="line">    childContextTypes: &#123;</div><div class="line">         fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    getChildContext: function() &#123;//如果不书写这个函数，子类则无法获取</div><div class="line">         return &#123; fruit: "Banana"，name: "Apple" &#125;;</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">         return <span class="tag">&lt;<span class="name">B</span> /&gt;</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var B = React.createClass(&#123;</div><div class="line">    contextTypes: &#123;</div><div class="line">        name: React.PropTypes.string.isRequired,</div><div class="line">        fruit: React.PropTypes.string.isRequired</div><div class="line">    &#125;,</div><div class="line">    render: function() &#123;</div><div class="line">        return <span class="tag">&lt;<span class="name">div</span>&gt;</span>My name is: &#123;this.context.name&#125; and my favorite fruit is: &#123;this.context.fruit&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;//由于父类限定了类型，所以如果是this.context.name就会报错</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">React.withContext(&#123;'name': 'Jonas'&#125;, function () &#123;//给A类，构造ContextTypes属性</div><div class="line">    React.render(<span class="tag">&lt;<span class="name">A</span> /&gt;</span>, document.body);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>关于跳转的方式,一种是用相应的history来push，一种是用context.router来push</li>
</ol>
<p>子类的<code>contextTypes</code>其实访问的是<code>Router</code>的<code>context</code>,<code>Router</code>有个叫router的<code>RouterContext</code>类型变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ruanyifen
    
    </summary>
    
      <category term="第三方库" scheme="https://xuecat.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>各个进制的表示195</title>
    <link href="https://xuecat.github.io/2016/11/07/195/"/>
    <id>https://xuecat.github.io/2016/11/07/195/</id>
    <published>2016-11-07T15:34:55.000Z</published>
    <updated>2016-11-07T15:39:41.577Z</updated>
    
    <content type="html"><![CDATA[<p>二进制好像vs2012以后才支持的吧，八进制表示在15上可以。</p>
<p> 二进制：0b011(3) 0B011(3)</p>
<p> 八进制: 00011(9); js是：0o011(9) 0O011(9)</p>
<p> 十六进制: 0x011(17) 0X011(17)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制好像vs2012以后才支持的吧，八进制表示在15上可以。&lt;/p&gt;
&lt;p&gt; 二进制：0b011(3) 0B011(3)&lt;/p&gt;
&lt;p&gt; 八进制: 00011(9); js是：0o011(9) 0O011(9)&lt;/p&gt;
&lt;p&gt; 十六进制: 0x011(17) 0X011(
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>js浅拷贝和深拷贝194</title>
    <link href="https://xuecat.github.io/2016/10/25/194/"/>
    <id>https://xuecat.github.io/2016/10/25/194/</id>
    <published>2016-10-25T13:39:04.000Z</published>
    <updated>2016-10-25T13:40:44.979Z</updated>
    
    <content type="html"><![CDATA[<p>浅拷贝：直接赋值<br><br>深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())<br></p>
<pre><code>var deepCopy = function(source) {
    var result={};
    for (var key in source) {
        result[key] = typeof source[key]===’object’? deepCoyp(source[key]): source[key];
    }
return result; 
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浅拷贝：直接赋值&lt;br&gt;&lt;br&gt;深拷贝：数组（nar=ar.slice(0)、nar=ar.concat()），对象(new Object())&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var deepCopy = function(source) {
    var res
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="语言" scheme="https://xuecat.github.io/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>node-npm指令193</title>
    <link href="https://xuecat.github.io/2016/10/24/193/"/>
    <id>https://xuecat.github.io/2016/10/24/193/</id>
    <published>2016-10-24T15:16:26.000Z</published>
    <updated>2016-10-24T15:18:57.980Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>npm查看全局安装过的包:<code>npm list -g --depth 0</code></p>
</li>
<li><p>删除node_module模块：<code>rimraf node_module</code></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;npm查看全局安装过的包:&lt;code&gt;npm list -g --depth 0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除node_module模块：&lt;code&gt;rimraf node_module&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>es6和js笔记192</title>
    <link href="https://xuecat.github.io/2016/10/19/192/"/>
    <id>https://xuecat.github.io/2016/10/19/192/</id>
    <published>2016-10-19T13:57:07.000Z</published>
    <updated>2016-11-29T14:17:01.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量命令"><a href="#变量命令" class="headerlink" title="变量命令"></a>变量命令</h3><p>####. var和let </p>
<ul>
<li>let只在其块级作用域内有效，而var却全局有效。</li>
<li>区块中有let和const，则这个区块暂时性死区；即区块会对这些命令声明的变量一开始就形成封闭作用域，只要在声明前使用这些变量，就会报错（相反var不会）</li>
</ul>
<h4 id="const命令只保证变量指向地址不变，不能保证数据不变。"><a href="#const命令只保证变量指向地址不变，不能保证数据不变。" class="headerlink" title="const命令只保证变量指向地址不变，不能保证数据不变。"></a>const命令只保证变量指向地址不变，不能保证数据不变。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = [];</div><div class="line">foo.prop = <span class="number">123</span>;<span class="comment">//这是被允许的</span></div><div class="line">foo = &#123;&#125;;<span class="comment">//这是不被允许的</span></div><div class="line"></div><div class="line"><span class="comment">//要完全冻结，参考如下代码</span></div><div class="line"><span class="keyword">var</span> constantize = (obj) =&gt; &#123;</div><div class="line">    <span class="built_in">Object</span>.freeze(obj);</div><div class="line">    <span class="built_in">Object</span>.key(obj).forEach((key, value) =&gt; &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</div><div class="line">            constantize(obj[key]);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><h4 id="字符遍历。（好像用-也可以遍历）"><a href="#字符遍历。（好像用-也可以遍历）" class="headerlink" title="字符遍历。（好像用[]也可以遍历）"></a>字符遍历。（好像用<code>[]</code>也可以遍历）</h4><p>es5: for (var i=0; i<str.length; i++)="" {alert(str.charat(i));}="" <br=""><br>es6: for (let i=0 of str) {alert(i);}</str.length;></p>
<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>es6多了:<br><br>includes:返回布尔，表示十分找到参数字符串。第二个参数，表示开始搜索的位置<br>startsWith:返回布尔，表示参数字符串是否在源字符串的头部。第二个参数，表示开始搜索的位置<br>endsWith:返回布尔，表示参数字符串是否在源字符串的尾部。第二个参数，表示开始搜索的位置<br>repeat:返回一个新字符串，表示将原字符串重复n次</p>
<h4 id="模板字符串，使用反引号（-这个符号）"><a href="#模板字符串，使用反引号（-这个符号）" class="headerlink" title="模板字符串，使用反引号（`这个符号）"></a>模板字符串，使用反引号（`这个符号）</h4><p>普通字符： <code>dd&#39;\n&#39;asdf</code> 这里有换行<br>多行字符： 无需连接符，所有的空格、回车和缩进都会被保留在输出中。<br>变量嵌入：<code>hello ${name} are ${time}?</code> name和time是定义的变量。如果括号里面的不是字符串，则按一般规则转换为字符，如调用toString方法<br>函数调用：function tag(s, v, d); tag<code>hello ${a+b} ${a}</code>;<br>String的raw函数</p>
<h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>es5中String对象的方法，search、match、replace、split支持JS正则</p>
<h3 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h3><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>Number增加成员isFinite，isNaN.<br> es6把es5中的全局函数parseInt,parseFloat移植到了Number对象上。<br>Number成员，isSafeInteger范围在2的53次方</p>
<h4 id="Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s"><a href="#Math对象-es6新增17个方法。它的方法都是静态方法-Math-abs-s" class="headerlink" title="Math对象,es6新增17个方法。它的方法都是静态方法:Math.abs(s)"></a>Math对象,es6新增17个方法。它的方法都是静态方法:<code>Math.abs(s)</code></h4><p>Math.trunc(4.2)//除去一个数的小数部分，返回整数<br><br>Math.sign();//判断一个数是正数(re:+1)、负数(re:-1)、还是零(re:0)、其它(re:NaN)<br>Math.cbrt();//计算一个数的立方根<br>对数、指数、平方等就不写了。</p>
<h4 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h4><ul>
<li><p>from函数；伪组数转换：</p>
<p>  let arraylike = {</p>
<pre><code>0: &apos;a&apos;,
1: &apos;b&apos;,
length: 2//这个属性必须有
</code></pre><p>  };//注意这是个对象，并不是数组</p>
</li>
</ul>
<p>es5中转换数组：[].slice.call(arraylike);或这么写Array.prototype.slice.call(arraylike);//[‘a’, ‘b’];<br>es6中转换数组：Array.from(arraylike);<br>//只要部署了Iterator接口的数据结构，和ES6的Set、Map。都可以转换。<br><br>//如果参数是数组，则返回新数组<br><br>//from还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组中<br></p>
<pre><code>function test(a,b,c,d) 
{ 
    var arg = Array.prototype.slice.call(arguments,1); 
    alert(arg); 
} 
test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d
</code></pre><h4 id="find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10"><a href="#find返回的是第一个符合条件的元素-1-4-5-10-find-n-gt-n-lt-0-5-1-5-find-function-value-index-arr-return-value-gt-9-10" class="headerlink" title="find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10"></a>find返回的是第一个符合条件的元素:  [1, 4, -5, 10].find((n) =&gt; n &lt; 0)//-5    [1, 5].find(function(value, index, arr) { return value &gt; 9;})//10</h4><h4 id="fill填充数组"><a href="#fill填充数组" class="headerlink" title="fill填充数组"></a>fill填充数组</h4><h4 id="entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器"><a href="#entries-返回键值对遍历器，keys-返回值遍历器，values-返回键遍历器" class="headerlink" title="entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器"></a>entries()//返回键值对遍历器，keys()//返回值遍历器，values()//返回键遍历器</h4><pre><code>for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {}
for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {}
//es6有遍历器对象
</code></pre><h4 id="includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true"><a href="#includes-返回一个布尔值，表示某个数组是否包含给定值。-1-2-3-includes-2-true" class="headerlink" title="includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true"></a>includes()//返回一个布尔值，表示某个数组是否包含给定值。 [1, 2, 3].includes(2);//true</h4><h3 id="函数（函数参数默认压栈顺序，从左到右）"><a href="#函数（函数参数默认压栈顺序，从左到右）" class="headerlink" title="函数（函数参数默认压栈顺序，从左到右）"></a>函数（函数参数默认压栈顺序，从左到右）</h3><h4 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h4><p>es5 </p>
<pre><code>function log (x, y) { y = y || &apos;world&apos;;}
</code></pre><p>es6</p>
<pre><code>function log(x, y = &apos;world&apos;) {}
</code></pre><ul>
<li><p>解构和默认参数</p>
<pre><code>function foo({x, y = 5}) { console.log(x, y);}
foo({})//undefined, 5
foo({x:1})//1, 5
foo({x:1, y:2})//1, 2

function m1({x=0, y=0} = {}) {}
function m2({x, y} = {x:0, y:0}) {}
//上面俩个函数，在m({x:3})、m({})这种类型时，就不同
//它们顺序是先赋值参数，再执行构里面的默认值

//默认参数位置不用在尾部。但是调用要用undefined参数，如： f(undefined, 1)

//使用默认参数会相应减少length属性的值。(function(a, b, c = 5){}).length //2
</code></pre></li>
</ul>
<h4 id="rest参数和扩展运算符"><a href="#rest参数和扩展运算符" class="headerlink" title="rest参数和扩展运算符"></a>rest参数和扩展运算符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</div><div class="line">        sum += val;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="comment">//有了rest后，就可以不使用arguments；只是注意rest参数是数组，且后面不能再有其它参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</div><div class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</div><div class="line">        array.push(item);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = [];</div><div class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>扩展运算符也是加三个点(…)，好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arge = [<span class="number">4</span>, <span class="number">5</span>];</div><div class="line">f.apply(<span class="literal">null</span>, args);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line"><span class="built_in">Array</span>.prototype.push.apply(args, arge);</div><div class="line">args.concat(arge, arge);</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, w, v, h</span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>];</div><div class="line">f (<span class="number">-1</span>, ...args, ...[<span class="number">7</span>]);</div><div class="line"></div><div class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</div><div class="line">args.push(...arge);</div><div class="line">[...args, ...arge, ...arge];</div></pre></td></tr></table></figure>
<h4 id="function有name属性（浏览器支持，es6才标准）"><a href="#function有name属性（浏览器支持，es6才标准）" class="headerlink" title="function有name属性（浏览器支持，es6才标准）"></a>function有name属性（浏览器支持，es6才标准）</h4><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数内部没有自己的this，导致内部的this就是外层代码块的this。<br><br>除此外，arguments、super、new.target也是指向外层函数对应的。</p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//es5</span></div><div class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</div><div class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span> </span>&#123;&#125;<span class="comment">//此处，class对语法解析器来说是个关键字，为了让语法解析器解析为属性函数，必须加单引号</span></div><div class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//es6</span></div><div class="line"><span class="keyword">var</span> baz = &#123;foo: <span class="string">'bar'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="class"><span class="keyword">class</span>() </span>&#123;&#125;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'he'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//书上说CommonJS模块输出变量，我感觉这代码很单独js文件时来借鉴，这样很方便导入使用</span></div><div class="line"><span class="keyword">var</span> ms = &#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ms = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;getItem, setItem, clear&#125;;</div><div class="line"><span class="comment">//等同于</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    getItem: getItem,</div><div class="line">    setItem: setItem,</div><div class="line">    clear: clear</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="属性名表达式-使用-来实现"><a href="#属性名表达式-使用-来实现" class="headerlink" title="属性名表达式(使用[]来实现)"></a>属性名表达式(使用[]来实现)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对属性的定义有俩种(es5只能用方法一)</span></div><div class="line">obj.foo = <span class="number">123</span>;</div><div class="line">obj[<span class="string">'f'</span> + <span class="string">'oo'</span>] = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//当多个定义的时候</span></div><div class="line"><span class="keyword">var</span> na = <span class="number">4</span>;</div><div class="line"><span class="keyword">var</span> hh = <span class="string">'wq'</span>;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    <span class="string">'pp'</span>: <span class="number">2</span>,</div><div class="line">    [<span class="string">'a'</span> + na]: <span class="number">3</span>,</div><div class="line">    [wq]: <span class="number">4</span>,</div><div class="line">    [<span class="string">'a'</span> + wq]: <span class="number">5</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//另外（表达式虽然可以使用，但是表达式计算的结果是全数字的话（数字开头也算），访问属性时会混乱出错）</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a.obj = <span class="number">3</span>;</div><div class="line">a[obj];<span class="comment">//error</span></div><div class="line">a[<span class="string">'obj'</span>];<span class="comment">//ok  因为点运算符后面总是字符串</span></div><div class="line"></div><div class="line"><span class="number">1</span>、对js来说属性名一定是字符串，不可能是其它对象</div><div class="line"><span class="number">2</span>、[]运算出来的只能是字符串，</div><div class="line"><span class="number">3</span>、[]里面的只能是对象，<span class="string">`['obj']`</span>是生产一个<span class="string">`obj`</span>的字符串，再转换</div></pre></td></tr></table></figure>
<h5 id="name的俩种特殊情况："><a href="#name的俩种特殊情况：" class="headerlink" title="name的俩种特殊情况："></a>name的俩种特殊情况：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></div></pre></td></tr></table></figure>
<h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>除了个别（NaN、+0、-0）和<code>===</code>不一样，其它都一致。 </p>
<h4 id="Object。assign"><a href="#Object。assign" class="headerlink" title="Object。assign()"></a>Object。assign()</h4><p>它会从左向右，依次把元素叠加到第一个参数上，并返回第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> target = &#123; a: <span class="number">1</span>, b: <span class="number">1</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> source1 = &#123; b: <span class="number">2</span>, c: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> source2 = &#123; c: <span class="number">3</span> &#125;;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</div><div class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125; 注意assign只是浅拷贝</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">Object</span>(<span class="string">'abc'</span>) <span class="comment">// &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125;</span></div><div class="line"><span class="comment">//如果组合的话，只进字符。</span></div><div class="line"></div><div class="line"><span class="comment">//Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性）</span></div><div class="line"><span class="comment">//也不拷贝不可枚举的属性（enumerable: false）。</span></div><div class="line"></div><div class="line"><span class="comment">//如果要保持继承链</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="属性的可枚举"><a href="#属性的可枚举" class="headerlink" title="属性的可枚举"></a>属性的可枚举</h4><p>es5有三个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性<br>es6多个<code>assign</code></li>
</ul>
<h4 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h4><p>书上建议使用<br><code>Object.setPrototypeOf()</code>（写操作）、<br><code>Object.getPrototypeOf()</code>（读操作）、<br><code>Object.create()</code>（生成操作）代替 <code>__proto__</code>的直接操作，因为只有浏览器广泛支持，其它环境不一定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">setPrototypeOf(obj, proto) &#123;</div><div class="line">  obj.__proto__ = proto;</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;<span class="comment">//setPrototypeOf的原型和它差不多，也就意味着这是浅拷贝。</span></div><div class="line"><span class="keyword">let</span> proto = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> obj = &#123; x: <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</div><div class="line"></div><div class="line">proto.y = <span class="number">20</span>;</div><div class="line">proto.z = <span class="number">40</span>;</div><div class="line"></div><div class="line">obj.x <span class="comment">// 10</span></div><div class="line">obj.y <span class="comment">// 20</span></div><div class="line">obj.z <span class="comment">// 40</span></div></pre></td></tr></table></figure>
<h4 id="Object-keys-和values相对"><a href="#Object-keys-和values相对" class="headerlink" title="Object.keys 和values相对"></a>Object.keys 和values相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.keys(obj)</div><div class="line"><span class="comment">// ["foo", "baz"]</span></div></pre></td></tr></table></figure>
<h4 id="Object-values-和keys相对"><a href="#Object-values-和keys相对" class="headerlink" title="Object.values 和keys相对"></a>Object.values 和keys相对</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">"bar"</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.values(obj)</div><div class="line"><span class="comment">// ["bar", 42]</span></div></pre></td></tr></table></figure>
<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</div><div class="line"><span class="built_in">Object</span>.entries(obj)</div><div class="line"><span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></div></pre></td></tr></table></figure>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>从字面上理解，是为了属性引入新方法，同时避免重名的情况；保证属性名独一无二。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();<span class="comment">//它接收字符的，Symbol('a'),这样多了个字符串标识</span></div><div class="line"><span class="keyword">var</span> a = &#123;[mySymbol]: <span class="string">'H!'</span>&#125;;<span class="comment">//由于Symbol是函数，所以必须用属性名表达式</span></div><div class="line"></div><div class="line"><span class="comment">//还有一种使用方式是定义常量,感觉蛮实用的</span></div><div class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (color) &#123;</div><div class="line">    <span class="keyword">case</span> COLOR_RED:</div><div class="line">      <span class="keyword">return</span> COLOR_GREEN;</div><div class="line">    <span class="keyword">case</span> COLOR_GREEN:</div><div class="line">      <span class="keyword">return</span> COLOR_RED;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="魔术字符串"><a href="#魔术字符串" class="headerlink" title="魔术字符串"></a>魔术字符串</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (shape) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: <span class="comment">// 魔术字符串</span></div><div class="line">getArea(<span class="string">'Triangle'</span>, &#123; width: <span class="number">100</span>, height: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></div><div class="line"><span class="comment">//作者建议为了减少代码的耦合性，应尽量用变量代替来消除魔术字符串。</span></div><div class="line"><span class="keyword">switch</span> (shape) &#123;</div><div class="line">    <span class="keyword">case</span> shapeType.triangle:</div><div class="line">getArea(shapeType.triangle, &#123; width: <span class="number">100</span>, height: <span class="number">100</span> &#125;);</div><div class="line"></div><div class="line"><span class="comment">//由于并不在意其值，所以用此。</span></div><div class="line"><span class="keyword">const</span> shapeType = &#123;</div><div class="line">  triangle: <span class="built_in">Symbol</span>()</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="Symbol属性函数"><a href="#Symbol属性函数" class="headerlink" title="Symbol属性函数"></a>Symbol属性函数</h5><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 <code>Symbol</code> 值。</p>
<p><code>Symbol.for()</code>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'ff'</span>);</div><div class="line">s1 === s2<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p><code>Symbol.keyFor()</code>返回一个已登记的<code>Symbol</code>类型的key；<br>换句话说，它对<code>Symbol.for</code>返回成功的是能返回的。<br>对新建的<code>Symbol(&lt;string&gt;)</code>类型是无法返回的。</p>
<h3 id="Proxy-属于元编程"><a href="#Proxy-属于元编程" class="headerlink" title="Proxy(属于元编程)"></a>Proxy(属于元编程)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">obj.count = <span class="number">1</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line">++obj.count</div><div class="line"><span class="comment">//  getting count!</span></div><div class="line"><span class="comment">//  setting count!</span></div><div class="line"><span class="comment">//  2</span></div><div class="line"></div><div class="line"><span class="comment">//同一个拦截器，可以设置多个操作</span></div><div class="line"><span class="keyword">var</span> handler = &#123;</div><div class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, name</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (name === <span class="string">'prototype'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + name;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, thisBinding, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> args[<span class="number">0</span>];</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;value: args[<span class="number">1</span>]&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;, handler);</div><div class="line"></div><div class="line">fproxy(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 1</span></div><div class="line"><span class="keyword">new</span> fproxy(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// &#123;value: 2&#125;</span></div><div class="line">fproxy.prototype === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></div><div class="line">fproxy.foo <span class="comment">// "Hello, foo"</span></div></pre></td></tr></table></figure>
<p><strong>总的来说有点像c++的操作符函数，但比操作符函数高级</strong><br>支持一下特性：</p>
<ol>
<li><code>get(target, propKey, receiver)</code>拦截对象属性读取</li>
<li><code>set(target, propKey, value, receiver)</code>拦截对象属性的设置 返回一个布尔值。</li>
<li><code>has(target, propKey)</code>拦截propKey in proxy的操作，以及对象的hasOwnProperty方法 返回一个布尔值。</li>
<li><code>deleteProperty(target, propKey)</code>拦截delete proxy[propKey]的操作 返回一个布尔值。</li>
<li><code>ownKeys(target)</code>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组</li>
<li><code>getOwnPropertyDescriptor(target, propKey)</code>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li><code>defineProperty(target, propKey, propDesc)</code>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li><code>preventExtensions(target)</code>拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li><code>getPrototypeOf(target)</code>拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li><code>isExtensible(target)</code>拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li><code>setPrototypeOf(target, proto)</code>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</li>
<li><code>apply(target, object, args)</code>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</li>
<li><code>construct(target, args)</code>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ol>
<p><strong>这个确实太多了，也没咋记，具体看书吧！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;变量命令&quot;&gt;&lt;a href=&quot;#变量命令&quot; class=&quot;headerlink&quot; title=&quot;变量命令&quot;&gt;&lt;/a&gt;变量命令&lt;/h3&gt;&lt;p&gt;####. var和let &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let只在其块级作用域内有效，而var却全局有效。&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS-Google语法191</title>
    <link href="https://xuecat.github.io/2016/10/17/191/"/>
    <id>https://xuecat.github.io/2016/10/17/191/</id>
    <published>2016-10-17T13:09:30.000Z</published>
    <updated>2016-11-20T08:49:51.513Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>如果一个值是恒定的，它命名中的字母要全部大写（如 <code>CONSTANT_VALUE_CASE</code> ）</li>
<li><p>一定要分号，js是弱语言，很多时候不要分号也能执行。但是容易出错。</p>
<p> //函数表达式后面要分号结束，但是函数声明就不需要</p>
<pre><code>var foo = function() {
    return true;
};  // 这里要分号

function foo() {
    return true;
}  // 这里不用分号
</code></pre></li>
<li><p>不要在块内函数声明，应该使用一个变量初始化函数表达式在块内定义一个函数块</p>
</li>
<li>为了最大的可移植性和兼容性，总是使用标准功能而不是非标准功能（例如，采用 string.charAt(3) 而非 string[3] ，用DOM的功能访问元素而不是使用特定于一个具体应用的简写）。</li>
<li><p>原始类型的包装对象，</p>
<pre><code>var x = new Boolean(false);
if (x) {//这是错误的，因为x是个object，而不是bool，正确该是var x = Boolean(0);
    alert(&apos;hi&apos;);  //显示“hi”。
}
</code></pre></li>
<li><p>方法和属性定义</p>
</li>
</ol>
<p>虽然有多种使用“new”关键词来创建对象方法和属性的途径，首选的创建方法的途径是：</p>
<pre><code>Foo.prototype.bar = function() {
    /* ... */
};//好像这样能提供性能
</code></pre><p>其他特性的首选创建方式是在构造函数中初始化字段：</p>
<pre><code>/** @constructor */
function Foo() {
    this.bar = value;
}
</code></pre><ol>
<li>删除，使用this.foo == null,而不是delete</li>
<li>遍历数组使用for循环 而不是for-in</li>
<li>多行字符不要使用连接行符，直接’+’</li>
<li>构建数组对象用字面量，而不是构造函数。</li>
</ol>
<p>//问题在构造只有一个元素的函数时</p>
<pre><code>var a = new Array(x); //它表示的是开辟一个x大小的数组，内部赋值undifinew；而不是开辟一个数组，内部赋值x；
var a = [x1, x2];
var a = [x1];
var a = [];
</code></pre><p>对象构造函数，为了一致性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    o2.a = <span class="number">0</span>;</div><div class="line">    o2.b = <span class="number">1</span>;</div><div class="line">    o2.c = <span class="number">2</span>;</div><div class="line">    o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;</div><div class="line"></div><div class="line">改为：</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> o2 = &#123;</div><div class="line">        a: <span class="number">0</span>,</div><div class="line">        b: <span class="number">1</span>,</div><div class="line">        c: <span class="number">2</span>,</div><div class="line">        <span class="string">'strange key'</span>: <span class="number">3</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//关于对象属性的设置和获取，也最好使用字面量；请看`192`第15条</span></div></pre></td></tr></table></figure>
<ol>
<li>强烈禁止修改如 Object.prototype 和 Array.prototype 等对象的原型。</li>
<li>不要使用条件注释；条件注释会在运行时改变JavaScript语法树，阻碍自动化工具。</li>
<li>私有 属性和方法应该以下划线开头命名</li>
<li>保护 属性和方法应该以无下划线开头命名（像公共属性和方法一样）。</li>
<li>可选函数参数以 opt_ 开头。</li>
<li>参数数目可变的函数应该具有以 var_args 命名的最后一个参数。</li>
<li>为了避免在大小写敏感的平台上引起混淆，文件名应该小写。文件名应该以 .js 结尾，并且应该不包含除了 - 或 <em> （相比较 </em> 更推荐 - ）以外的其它标点</li>
<li><p>括号书写：</p>
<pre><code>if (something) {
} else {
}
</code></pre></li>
<li><p>多行，对象和数组初始化</p>
<pre><code>var arr = [1, 2, 3];  //之后无空格[或之前]
var obj = {a: 1, b: 2, c: 3};  //之后无空格[或之前]

//不要像这样：

WRONG_Object.prototype = {
    a          : 0,
    b          : 1,
    lengthyName: 2
};
</code></pre></li>
<li><p>匿名函数传递</p>
<pre><code>prefix.something.reallyLongFunctionName(&apos;whatever&apos;, function(a1, a2) {
    if (a1.equals(a2)) {
        someOtherLongFunctionName(a1);
    } else {
        andNowForSomethingCompletelyDifferent(a2.parrot);
    }
});

var names = prefix.something.myExcellentMapFunction(
    verboselyNamedCollectionOfItems,
    function(item) {
        return item.name;
    });
</code></pre></li>
<li><p>字符串使用单引号，虽然js不区分单引号和双引号。<br><br>但是一般html的属性用的是双引号。所以当js字符串为了区分html和转义，最好使用单引号。</p>
</li>
<li>注释可以参考jsdoc的做法</li>
<li><p>布尔类型</p>
<pre><code>下边的布尔表达式都返回false：
//@
null
undefined
&apos;&apos;空字符串
数字0
//但是要小心，因为以下这些返回true：
字符串&quot;0&quot;
[]空数组
{}空对象

//@所以 while (x != null) {}这样不好， 该是 while(x) {}
//if (y != null &amp;&amp; y != &apos;&apos;) {} 也改成 if (y) {}

//@二元布尔操作符是可短路的,所以
    var win;
    if (opt_win) {
        win = opt_win;
    } else {
        win = window;
    }
    //可以改成：
    function foo(opt_win) {
        var win = opt_win || window;
    }

    if (node) {
        if (node.kids) {
            if (node.kids[index]) {
                foo(node.kids[index]);
            }
        }
    }
    //可以改成：
    var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];
    if (kid) {
        foo(kid);
    }
</code></pre></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;如果一个值是恒定的，它命名中的字母要全部大写（如 &lt;code&gt;CONSTANT_VALUE_CASE&lt;/code&gt; ）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一定要分号，js是弱语言，很多时候不要分号也能执行。但是容易出错。&lt;/p&gt;
&lt;p&gt; //函数表达式后面要分号结束，但是
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="代码编写" scheme="https://xuecat.github.io/tags/%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99/"/>
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React记录190</title>
    <link href="https://xuecat.github.io/2016/10/16/190/"/>
    <id>https://xuecat.github.io/2016/10/16/190/</id>
    <published>2016-10-16T08:57:00.000Z</published>
    <updated>2016-11-21T13:49:10.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1. this.props.children</strong><br>它是链表没错(当只有一个时，是string之类元素)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">React.Children.map(<span class="keyword">this</span>.props.children, <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> &lt;li&gt;&#123;child&#125;&lt;/li&gt;;</div><div class="line">        &#125;)</div><div class="line"><span class="comment">//每个child是一个ReactElement的object，可能ReactElement有默认的隐式处理吧_shadowChildren之类吧！</span></div></pre></td></tr></table></figure>
<p>此句，一直不明白为何object能当字符处理。</p>
<p><strong>2. markdown显示</strong><br>使用remarkable库，可以支持markdown格式显示语句。<br><br>但是不能直接render解析（虽然表面看是对的），好像react做了XSS 攻击的保护。<br><br>解析后的语句只能放入节点属性中：dangerouslySetInnerHTML={ __html: md.render(this.props.children.toString()) }<br><br>值得注意的是，它支持的markdown语法是最新的，也就是说有些语法严格和空格有关(如<code># d</code>必须空格)</p>
<p><strong>3. react key添加</strong><br>我在用map的时候，被警告必须加key。react对dom做遍历的时候，会根据data-reactid生成虚拟dom树。如果你没有手动的添加unique constant key的话，react是无法记录你的dom操作的。</p>
<p><strong>4. createClass函数问题</strong><br>createClass创建的方法</p>
<p><code>rawMarkup: function() {}</code></p>
<p>要<code>this.rawMarkup()</code>才能访问到；晕，刚居然没注意。</p>
<p><strong>5. eslint安装</strong><br>eslint和eslint插件必须全部 全局安装。局部安装老是报错，无法找到插件。</p>
<p><strong>6. react-es6</strong><br>这个由于很多，只说下属性的设置；<br>es5对类属性设置是用： <code>render: function(){}</code><br><br>es6对类属性设置是用：<code>render() {}</code><br><br>居然看半天没发现。<br><a href="http://blog.csdn.net/wangzengdi/article/details/50719395" target="_blank" rel="external">http://blog.csdn.net/wangzengdi/article/details/50719395</a></p>
<p><strong>7. 无状态的函数式组件</strong><br>除了正统的rn创建外；还有个创建组件的方法<br></p>
<p>声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Pane = (props) =&gt; &lt;div&gt;&#123;props.children&#125;&lt;/div&gt;;</div><div class="line">Pane.propTypes = &#123;</div><div class="line">  label: React.PropTypes.string.isRequired,</div><div class="line">  children: React.PropTypes.element.isRequired</div><div class="line">&#125;;</div><div class="line"><span class="comment">//使用：</span></div><div class="line">&lt;Pane label=<span class="string">"asdf"</span> /&gt;</div></pre></td></tr></table></figure>
<p>注意俩点：</p>
<ol>
<li>不能有生命周期方法</li>
<li>不能有ref（实例dom属性，React.findDOMNode）</li>
</ol>
<p><strong>8. children isrequired</strong><br><code>children: React.PropTypes.element.isRequired</code></p>
<p><strong>9. react全家桶</strong><br>webpack和其它基本已经知道了；给个前端ui库吧：reactui库有个ant design 和material ui、 boostrap<br><br>flux网上说文档又臭又长，转redux</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1. this.props.children&lt;/strong&gt;&lt;br&gt;它是链表没错(当只有一个时，是string之类元素)&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
    
    </summary>
    
      <category term="第三方库" scheme="https://xuecat.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="react" scheme="https://xuecat.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>换系统时要保存的文件189</title>
    <link href="https://xuecat.github.io/2016/10/12/189/"/>
    <id>https://xuecat.github.io/2016/10/12/189/</id>
    <published>2016-10-12T15:32:07.000Z</published>
    <updated>2016-11-12T08:33:54.444Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="/picture/e1.jpg" alt=""></div></div><div class="group-picture-row"></div></div></div>
<ul>
<li>vscode 插件项</li>
<li>桌面的<code>笔记.txt</code></li>
</ul>
<p>今天真是超级扯淡的一天：</p>
<ul>
<li>sp1系统和其它非ultimate系统（msdn我告诉你），没有系统更新模块；sp1到无所谓，模块集成了，只是没法英文系统而已。</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！</li>
<li>电脑更新和安装vs，不要插移动硬盘！ 尼玛，它会直接破坏小马的系统激活，气死我了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;widt
    
    </summary>
    
      <category term="配置" scheme="https://xuecat.github.io/categories/%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>CFile各属性笔记188</title>
    <link href="https://xuecat.github.io/2016/09/27/188/"/>
    <id>https://xuecat.github.io/2016/09/27/188/</id>
    <published>2016-09-27T14:09:47.000Z</published>
    <updated>2016-09-27T14:39:50.818Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今日为楼下写多线程的文件操作测试程序，记录下。</strong></p>
<p>CFile::shareDenyNone 表示允许其它进/线程访问（多线程时便用此CFile::shareDenyNone和CFile::shareDenyNone搭配，对文件边读边写）</p>
<p>CFile::shareDenyRead 禁止其它进/线程读操作</p>
<p>CFile::shareDenyWrite 禁止其它进/线程写操作</p>
<p>CFile::shareExclusive 禁止其它进/线程读写操作</p>
<p>CFile::modeNoTruncate 它必须要和CFile::modeCreate连用保证稳定性。好吧对于它一般是写操作时用的多，<br><br>CFile::modeCreate会清零文件，即原来文件80k，你写入50k，这下文件就只有50k新数据。<br><br>CFile::modeNoTruncate不会清零文件，即原来80k，写入50k，这下文件就有50k新数据和30k旧数据。如果想对尾部添加的话直接seek到end就好<br></p>
<p><strong>CFile::osNoBuffer 不会有系统缓存。它太特殊了，今天就卡这儿；它对文件操作必须按照卷大小来操作：也就是说添加此属性的CFile，seek、read、write的操作大小必须是1024的倍数</strong> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;今日为楼下写多线程的文件操作测试程序，记录下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CFile::shareDenyNone 表示允许其它进/线程访问（多线程时便用此CFile::shareDenyNone和CFile::shareDenyNone搭配，对文件边
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>npm install注意187</title>
    <link href="https://xuecat.github.io/2016/09/26/187/"/>
    <id>https://xuecat.github.io/2016/09/26/187/</id>
    <published>2016-09-26T15:34:46.000Z</published>
    <updated>2016-09-29T00:24:42.293Z</updated>
    
    <content type="html"><![CDATA[<p><code>--save-dev</code> 是你开发时候依赖的东西，<code>--save</code> 是你发布之后还依赖的东西。</p>
<p>比如，你写 ES6 代码，如果你想编译成 ES5 发布那么 babel 就是devDependencies。<br><br>如果你用了 jQuery，由于发布之后还是依赖jQuery，所以是dependencies。</p>
<p>但是在 npm 里面除了二进制的依赖，似乎也不用区分是不是dev。<br><br>因为使用npm就是自己编译的意思，而不使用npm直接拿编译后的版本的，这些依赖项也看不到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;--save-dev&lt;/code&gt; 是你开发时候依赖的东西，&lt;code&gt;--save&lt;/code&gt; 是你发布之后还依赖的东西。&lt;/p&gt;
&lt;p&gt;比如，你写 ES6 代码，如果你想编译成 ES5 发布那么 babel 就是devDependencies。&lt;br&gt;&lt;b
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="工具" scheme="https://xuecat.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>google调试react186</title>
    <link href="https://xuecat.github.io/2016/09/25/186/"/>
    <id>https://xuecat.github.io/2016/09/25/186/</id>
    <published>2016-09-25T09:01:40.000Z</published>
    <updated>2016-10-18T16:36:11.529Z</updated>
    
    <content type="html"><![CDATA[<p>今天死活断点不了，google了好久；发现有个<code>debugger</code>放入代码中就好了，可以看堆栈了。<br><br>断点不了的问题至今没找到，气死人了。！</p>
<p>好吧v2ex果然大神多，jsx需要编译产生sourcemap后才能被调试，所以webpack是标配。另外react-hot-loader（js库）和react-devtools（google插件）不错</p>
<p><code>Create React App</code>和<code>generator-react-webpack</code>会自动生成react项目，使用webpack自动打包，但是<code>dev-source-map</code>模式下无法调试。<br><br>其它模式参考：<a href="https://segmentfault.com/a/1190000004280859" target="_blank" rel="external">https://segmentfault.com/a/1190000004280859</a></p>
<p>调试的jsx，一般都是被打包成js的，很好看，也方便调试（就google-&gt;source 那里找源码有点不好找，打包多了）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天死活断点不了，google了好久；发现有个&lt;code&gt;debugger&lt;/code&gt;放入代码中就好了，可以看堆栈了。&lt;br&gt;&lt;br&gt;断点不了的问题至今没找到，气死人了。！&lt;/p&gt;
&lt;p&gt;好吧v2ex果然大神多，jsx需要编译产生sourcemap后才能被调试，所以web
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="杂项" scheme="https://xuecat.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
      <category term="错误认识" scheme="https://xuecat.github.io/tags/%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86/"/>
    
      <category term="google-chrome" scheme="https://xuecat.github.io/tags/google-chrome/"/>
    
  </entry>
  
  <entry>
    <title>JS中单引号与双引号的一个区别185</title>
    <link href="https://xuecat.github.io/2016/09/25/185/"/>
    <id>https://xuecat.github.io/2016/09/25/185/</id>
    <published>2016-09-25T02:30:36.000Z</published>
    <updated>2016-09-25T04:44:40.333Z</updated>
    
    <content type="html"><![CDATA[<p>一般Javascript资料里面，很少区分单引号(‘)和双引号(“)，认为它们作用相同，今天发现有一处不同点，举例如下：</p>
<pre><code>在一段JS语句中，希望通过编程在网页中动态添加一个命令按钮， 则基本实现语句如下所示 

      var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定/&gt;&quot;);
      document.body.appendChild(btnOk2);
若要在点击按钮后显示一个提示信息，则要对其onclick事件编程，此时有多种方法可以实现。

1. 添加函数

      onclick=clickOK();//clickOK()为单独定义的函数

      function clickOK(){

         alert(&quot;确定&quot;);

      }

2. 使用匿名函数

      onclick=function(){alert(&apos;确定&apos;)};//注意，此处alert内的提示信息应使用单引号，若使用双引号则放入整个input 时语法不正确

3. 直接使用javascript语句，单引号

      onclick=&apos;javascript:{alert(&apos;确定&apos;)&apos;;//注意，此语句语法没问题，但却不能正常执行，点击按钮时无结果，具体原因不详，也未深究

4. 直接使用javascript语句，双引号

      由于要放入input语句中，因此alert不能直接使用双引号，使用转义符/完成

      onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;;//注意，此语句语法没问题，也能够正常执行

使用第4中方法的完整实例语句如下：

var btnOk2=document.createElement(&quot;&lt;input type=&apos;button&apos; value=&apos;确定 onclick=&apos;javascript:alert(/&quot;确定/&quot;)&apos;/&gt;&quot;);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般Javascript资料里面，很少区分单引号(‘)和双引号(“)，认为它们作用相同，今天发现有一处不同点，举例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在一段JS语句中，希望通过编程在网页中动态添加一个命令按钮， 则基本实现语句如下所示 

      var btnOk2
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>critical_section临界区注意事项184</title>
    <link href="https://xuecat.github.io/2016/09/22/184/"/>
    <id>https://xuecat.github.io/2016/09/22/184/</id>
    <published>2016-09-22T13:50:33.000Z</published>
    <updated>2016-09-22T13:53:00.253Z</updated>
    
    <content type="html"><![CDATA[<p>EnterCriticalSection作为临界区</p>
<p>critical_section效率要高一些，因为是针对同一个进程的。<br>mutex是针对整个操作系统的。</p>
<p>//1.测试同一线程两次EnterCriticalSection会不会阻塞<br>//答案:不会<br>/*</p>
<p>//2.测试同一线程两次EnterCriticalSection，调用一次LeaveCriticalSection 另一个线程是否可以以EnterCriticalSection<br>//答案:不可以 两次EnterCriticalSection 必须调用 LeaveCriticalSection两次</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EnterCriticalSection作为临界区&lt;/p&gt;
&lt;p&gt;critical_section效率要高一些，因为是针对同一个进程的。&lt;br&gt;mutex是针对整个操作系统的。&lt;/p&gt;
&lt;p&gt;//1.测试同一线程两次EnterCriticalSection会不会阻塞&lt;br&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://xuecat.github.io/categories/Windows/"/>
    
    
      <category term="函数和结构" scheme="https://xuecat.github.io/tags/%E5%87%BD%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%84/"/>
    
      <category term="多线程" scheme="https://xuecat.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在VSCode开发react环境过程IDE183</title>
    <link href="https://xuecat.github.io/2016/09/21/183/"/>
    <id>https://xuecat.github.io/2016/09/21/183/</id>
    <published>2016-09-21T15:54:37.000Z</published>
    <updated>2016-11-13T02:15:32.030Z</updated>
    
    <content type="html"><![CDATA[<p>###过程多了186也有，这里这说下开发环境，有利工具</p>
<ol>
<li><p>代码语法提示，插件ESLint；它对写的代码进行语法错误提示，特别是配置了react的插件后，对react属性、状态等书写有全面提示。</p>
</li>
<li><p>代码自动补全，node插件Typings和vsc插件Typings suto installer，前者全局安装，后者会自动把package.jason的TS（微软的TypingScript）包全下全</p>
</li>
<li><p>Debugger for Chrome,这个很好就是配置不好弄，用google远程调试协议来达到vsc本地调试，它的example可以直接下在本地使用。<br><br>example项目确实让人见识了很多东西；</p>
</li>
<li><p>Reactjs code snippets,这个很好专门的react的自动补全。</p>
</li>
<li><p>emment（内置，它简直为前端而生，语法很好使）；它默认是不支持js的，jsx倒是可以。<br><br>我google和官网了很久都没找到提示，最后没法，去git看看（原来git官网的doc是实时更新的，比官网的doc更新都勤快，以后只去git去看doc了）<br><br>在<code>.vscode</code>目录新建一个<code>settings.json</code>，加上<code>{&quot;emmet.syntaxProfiles&quot;: { &quot;javascript&quot;: &quot;html&quot; }}</code>便好了</p>
</li>
<li><p>调试和堆栈过程放186吧。</p>
</li>
</ol>
<ul>
<li><p>单个js调试，launch.json的配置  <a href="https://segmentfault.com/a/1190000004136202" target="_blank" rel="external">https://segmentfault.com/a/1190000004136202</a></p>
<p>  “name”: “启动”,<br>  “type”: “node”,<br>  “request”: “launch”,<br>  “program”: “${workspaceRoot}/demo01/tt.js”,</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###过程多了186也有，这里这说下开发环境，有利工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码语法提示，插件ESLint；它对写的代码进行语法错误提示，特别是配置了react的插件后，对react属性、状态等书写有全面提示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码自动补全，n
    
    </summary>
    
      <category term="CSS &amp; JS" scheme="https://xuecat.github.io/categories/CSS-JS/"/>
    
    
      <category term="JS" scheme="https://xuecat.github.io/tags/JS/"/>
    
      <category term="vscode" scheme="https://xuecat.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>仿函数和配接器的使用182</title>
    <link href="https://xuecat.github.io/2016/09/17/182/"/>
    <id>https://xuecat.github.io/2016/09/17/182/</id>
    <published>2016-09-17T14:38:08.000Z</published>
    <updated>2016-09-29T01:25:57.762Z</updated>
    
    <content type="html"><![CDATA[<p>要想使用stl配接器算法，unary_function、binary_function的仿函数就必须使用.</p>
<h3 id="先来看STL已经提供的仿函数"><a href="#先来看STL已经提供的仿函数" class="headerlink" title="先来看STL已经提供的仿函数"></a>先来看STL已经提供的仿函数</h3><h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2><h4 id="算法类仿函数"><a href="#算法类仿函数" class="headerlink" title="算法类仿函数"></a>算法类仿函数</h4><p>加法： <code>plus&lt;T&gt;</code> <br><br>减法：<code>minus&lt;T&gt;</code><br><br>乘法：<code>multiplies&lt;T&gt;</code><br><br>除法：<code>divides&lt;T&gt;</code> <br><br>模取：<code>modulus&lt;T&gt;</code><br><br>否定：<code>negate&lt;T&gt;</code>(一元)<br></p>
<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p>等于：<code>equal_to&lt;T&gt;</code><br><br>不等于：<code>not_equal_to&lt;T&gt;</code><br><br>大于：<code>greater&lt;T&gt;</code><br><br>大于或等于：<code>greater_equal&lt;T&gt;</code><br><br>小于：<code>less&lt;T&gt;</code><br><br>小于或等于:<code>less_equal&lt;T&gt;</code><br></p>
<h4 id="逻辑运算仿函数"><a href="#逻辑运算仿函数" class="headerlink" title="逻辑运算仿函数"></a>逻辑运算仿函数</h4><p>and: <code>logical_and&lt;T&gt;</code><br><br>or: <code>logical_or&lt;T&gt;</code><br><br>not: <code>logical_not&lt;T&gt;</code><br></p>
<h4 id="选择和投射"><a href="#选择和投射" class="headerlink" title="选择和投射"></a>选择和投射</h4><p><code>select1st&lt;T&gt;</code> <code>select2nd&lt;T&gt;</code> 对于此类，是针对pair的，传入pair，并返回第一个元素或第二个元素<br><br><code>project1st&lt;T&gt;</code> <code>project2nd&lt;T&gt;</code> 对于此类，是针对多参数的，传入俩个参数，只返回第一个元素或第二个元素<br></p>
<h2 id="—-1"><a href="#—-1" class="headerlink" title="—"></a>—</h2><h3 id="再看配接器"><a href="#再看配接器" class="headerlink" title="再看配接器"></a>再看配接器</h3><table>
<thead>
<tr>
<th>函数名</th>
<th style="text-align:center">实际效果</th>
<th style="text-align:center">实际对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#bind">bind(_Farg0::* const _Pmd, _Arg0&amp;&amp; _A0)</a></td>
<td style="text-align:center">11的新特性，auto配合万能绑定，参数能支持到20个参数，对成员函数绑定时第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#bind1st">bind1st(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(x, param)</td>
<td style="text-align:center">binder1st<op>(op, arg1_type(x))</op></td>
</tr>
<tr>
<td><a href="#bind2nd">bind2nd(const op&amp; op, const T&amp; x)</a></td>
<td style="text-align:center">op(param, x)</td>
<td style="text-align:center">binder2nd<op>(op, arg2_type(x))</op></td>
</tr>
<tr>
<td><a href="#not1">not1(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param)</td>
<td style="text-align:center">unary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#not2">not2(const Pred&amp; pred)</a></td>
<td style="text-align:center">!pred(param1, param2)</td>
<td style="text-align:center">binary_negate<pred>(pred)</pred></td>
</tr>
<tr>
<td><a href="#compose1">compose1(const Op1&amp; op1, const Op2&amp; op2)</a></td>
<td style="text-align:center">op1(op2(param))</td>
<td style="text-align:center">unary_compose<op1, op2="">(op1, op2)</op1,></td>
</tr>
<tr>
<td><a href="#compose2">compose2(<br>const Op1&amp; op1,<br> const Op2&amp; op2,<br> const Op3&amp; op3)</a></td>
<td style="text-align:center">op1(op2(param),<br> op3(param))</td>
<td style="text-align:center">binary_compose<op1, op2,="" op3=""><br>(op1, op2, op3)</op1,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg))</a></td>
<td style="text-align:center">fp(param)</td>
<td style="text-align:center">pointer_to_unary_function<arg, result="">(fp)</arg,></td>
</tr>
<tr>
<td><a href="#ptr_fun">ptr_fun(Result(*fp)(Arg1, Arg2))</a></td>
<td style="text-align:center">fp(param1, param2)</td>
<td style="text-align:center">pointer_to_binary_function<arg1, arg2,="" result="">(fp)</arg1,></td>
</tr>
<tr>
<td><a href="#mem_fn">mem_fn()</a></td>
<td style="text-align:center">11的新特性，auto配合，和bind绑定成员函数块差别不大，第一个参数默认为传入<code>对象</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)())</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun">mem_fun(S (T::*f)() const)</a></td>
<td style="text-align:center">(param-&gt;*f)()</td>
<td style="text-align:center">const_mem_fun_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)())</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun_ref">mem_fun_ref(S (T::*f)() const)</a></td>
<td style="text-align:center">(param.*f)()</td>
<td style="text-align:center">const_mem_fun_ref_t<s, t="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A))</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1">mem_fun1(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param-&gt;*f)(x)</td>
<td style="text-align:center">const_mem_fun1_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A))</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
<tr>
<td><a href="#mem_fun1_ref">mem_fun1_ref(S (T::*f)(A) const)</a></td>
<td style="text-align:center">(param.*f)(x)</td>
<td style="text-align:center">const_mem_fun1_ref_t<s, t,="" a="">(f)</s,></td>
</tr>
</tbody>
</table>
<hr>
<p></p><h2 id="bind"> bind <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">my_divide</span> <span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;<span class="keyword">return</span> x/y;&#125;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> MyPair &#123;</div><div class="line"><span class="keyword">double</span> a,b;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> a*b;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> Foo &#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_sum</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> data = <span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;    <span class="comment">//这里注意 adds visibility of _1, _2, _3,...</span></div><div class="line"></div><div class="line"><span class="comment">// binding functions:</span></div><div class="line"><span class="keyword">auto</span> fn_five = <span class="built_in">std</span>::bind (my_divide,<span class="number">10</span>,<span class="number">2</span>);               <span class="comment">// returns 10/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_five() &lt;&lt; <span class="string">'\n'</span>;                          <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_half = <span class="built_in">std</span>::bind (my_divide,<span class="number">_1</span>,<span class="number">2</span>);               <span class="comment">// returns x/2</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_half(<span class="number">10</span>) &lt;&lt; <span class="string">'\n'</span>;                        <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_invert = <span class="built_in">std</span>::bind (my_divide,<span class="number">_2</span>,<span class="number">_1</span>);            <span class="comment">// returns y/x</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_invert(<span class="number">10</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;                    <span class="comment">// 0.2</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> fn_rounding = <span class="built_in">std</span>::bind&lt;<span class="keyword">int</span>&gt; (my_divide,<span class="number">_1</span>,<span class="number">_2</span>);     <span class="comment">// returns int(x/y)</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fn_rounding(<span class="number">10</span>,<span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;                  <span class="comment">// 3</span></div><div class="line"></div><div class="line">MyPair ten_two &#123;<span class="number">10</span>,<span class="number">2</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// binding members:</span></div><div class="line"><span class="keyword">auto</span> bound_member_fn = <span class="built_in">std</span>::bind (&amp;MyPair::multiply,<span class="number">_1</span>); <span class="comment">// returns x.multiply()</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_fn(ten_two) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 20</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> bound_member_data = <span class="built_in">std</span>::bind (&amp;MyPair::a,ten_two); <span class="comment">// returns ten_two.a</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bound_member_data() &lt;&lt; <span class="string">'\n'</span>; </div><div class="line"></div><div class="line">Foo foo;</div><div class="line"><span class="keyword">auto</span> f3 = <span class="built_in">std</span>::bind(&amp;Foo::print_sum, foo, <span class="number">95</span>, <span class="number">_1</span>);</div><div class="line">f3(<span class="number">5</span>);</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="bind1st"> bind1st <h2><p></p>
<p></p><h2 id="bind2nd"> bind2nd <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; a - b &lt;&lt; <span class="built_in">endl</span>;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> <span class="number">_</span>tmain(<span class="keyword">int</span> argc, <span class="number">_</span>TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">    for_each(a, a+<span class="number">4</span>, bind1st(ptr_fun(fun), <span class="number">2</span>));<span class="comment">//此处由于，bind1st要传入适配器，所以要么fun继承前面的多元函数，要么如此处理</span></div><div class="line">    for_each(a, a+<span class="number">4</span>, bind2nd(ptr_fun(fun), <span class="number">2</span>));</div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not1"> not1 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">count_if(a, a+<span class="number">5</span>, not1(bind2nd(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">4</span>)))<span class="comment">//统计大于等于4的个数</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="not2"> not2 <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> h = accumulate(a, a+<span class="number">5</span>, <span class="number">4</span>, not2(ptr_fun(fun)));<span class="comment">//此中的not2然并卵作用，主要是自己无法想到好的二元算法了</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="compose1"> compose1 <h2><p></p>
<p></p><h2 id="compose2"> compose2 <h2><br><figure class="highlight c"><figcaption><span>它是GNU的所以vs STL没有，有源码如下++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1, <span class="keyword">class</span> <span class="number">_F</span>n2&gt;</div><div class="line"><span class="keyword">class</span> unary_compose</div><div class="line">    : <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt;</div><div class="line">&#123;    <span class="comment">// functor adapter _Func(stored, right)</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">typedef</span> unary_function&lt;<span class="keyword">typename</span> <span class="number">_F</span>n2::argument_type,</div><div class="line">        <span class="keyword">typename</span> <span class="number">_F</span>n1::result_type&gt; <span class="number">_B</span>ase;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::argument_type argument_type;</div><div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="number">_B</span>ase::result_type result_type;</div><div class="line"></div><div class="line">    unary_compose(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1,</div><div class="line">        <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">        : op1(<span class="number">_F</span>unc1), op2(<span class="number">_F</span>unc2)</div><div class="line">        &#123;    <span class="comment">// construct from functor and left operand</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">(argument_type&amp; <span class="number">_</span>Value)</span> <span class="keyword">const</span></span></div><div class="line">        &#123;    <span class="comment">// apply functor to operands</span></div><div class="line">        <span class="keyword">return</span> (op1(op2(<span class="number">_</span>Value)));</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="number">_F</span>n1 op1;    <span class="comment">// the functor to apply</span></div><div class="line">    <span class="number">_F</span>n2 op2;    <span class="comment">// the functor to apply</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="number">_F</span>n1,</div><div class="line"><span class="keyword">class</span> <span class="number">_F</span>n2&gt; <span class="keyword">inline</span></div><div class="line">unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt; compose1(<span class="keyword">const</span> <span class="number">_F</span>n1&amp; <span class="number">_F</span>unc1, <span class="keyword">const</span> <span class="number">_F</span>n2&amp; <span class="number">_F</span>unc2)</div><div class="line">&#123;    <span class="comment">// return a unary_compose functor adapter</span></div><div class="line">    <span class="keyword">return</span> (unary_compose&lt;<span class="number">_F</span>n1, <span class="number">_F</span>n2&gt;(<span class="number">_F</span>unc1, <span class="number">_F</span>unc2));</div><div class="line">&#125;</div><div class="line"></div><div class="line">for_each(a, a+<span class="number">5</span>, compose1(bind2nd(multiplies&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>), bind2nd(plus&lt;<span class="keyword">int</span>&gt;(), <span class="number">2</span>))); </div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="ptr_fun"> ptr_fun <h2><p></p>
<blockquote>
<p>上面已经有代码演示，无需</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fun"> mem_fun <h2><br><figure class="highlight c"><figcaption><span>成员对象必须是指针++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>*&gt; numbers;</div><div class="line"></div><div class="line"><span class="comment">// populate vector of pointers:</span></div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"one"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"two"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"three"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"four"</span>) );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"five"</span>) );</div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lengths ( numbers.size() );</div><div class="line"></div><div class="line">transform (numbers.begin(), numbers.end(), lengths.begin(), mem_fun(&amp;<span class="built_in">string</span>::length));</div><div class="line">    </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *numbers[i] &lt;&lt; <span class="string">" has "</span> &lt;&lt; lengths[i] &lt;&lt; <span class="string">" letters.\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// deallocate strings:</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt;::iterator it = numbers.begin(); it!=numbers.end(); ++it)</div><div class="line">    <span class="keyword">delete</span> *it;</div><div class="line"></div></pre></td></tr></table></figure><p></p>
<hr>
<p></p><h2 id="mem_fun1"> mem_fun1 <h2><p></p>
<blockquote>
<p>这个函数并不像<code>实际效果</code>那样，它应该是俩个参数，且各个绑定不同。<br>此函数11之后被淘汰</p>
</blockquote>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> dd &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       dd() &#123;&#125;</div><div class="line">       ~dd() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">aa</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; a - <span class="number">1</span>  &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> a - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind2nd(mem_fun1(&amp;dd::aa), <span class="number">2</span>));<span class="comment">//如此便是循环执行：iterator-&gt;aa(2);</span></div><div class="line"></div><div class="line">   <span class="comment">////////////////////////////</span></div><div class="line">   numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line">numbers.push_back ( <span class="keyword">new</span> dd );</div><div class="line"></div><div class="line">   <span class="keyword">class</span> aa &#123;</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">       aa() &#123;&#125;</div><div class="line">       ~aa() &#123;&#125;</div><div class="line">       <span class="function"><span class="keyword">int</span> <span class="title">dd</span><span class="params">(dd* a)</span> </span>&#123;</div><div class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="number">33</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line">   aa s;</div><div class="line">   for_each (numbers.begin(), numbers.end(), bind1st(mem_fun1(&amp;aa::dd), &amp;s));<span class="comment">//如此便是循环执行：(&amp;s)-&gt;dd(iterator);</span></div><div class="line"></div></pre></td></tr></table></figure>
<hr>
<p></p><h2 id="mem_fun_ref"> mem_fun_ref <h2><p></p>
<p></p><h2 id="mem_fun1_ref"> mem_fun1_ref <h2><p></p>
<blockquote>
<p>它们和<code>mem_fun</code>区别在于，iterator是对象，而不是指针。<br>mem_fun1_ref此函数11之后被淘汰</p>
</blockquote>
<hr>
<p></p><h2 id="mem_fn"> mem_fn <h2><br><figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">   dd a;</div><div class="line"><span class="keyword">auto</span> triple = <span class="built_in">std</span>::mem_fn(&amp;dd::aa);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; triple(a, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//以a为调用对象，传入2</span></div><div class="line"></div></pre></td></tr></table></figure><p></p>
</h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要想使用stl配接器算法，unary_function、binary_function的仿函数就必须使用.&lt;/p&gt;
&lt;h3 id=&quot;先来看STL已经提供的仿函数&quot;&gt;&lt;a href=&quot;#先来看STL已经提供的仿函数&quot; class=&quot;headerlink&quot; title=&quot;先来看
    
    </summary>
    
      <category term="语言" scheme="https://xuecat.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c函数" scheme="https://xuecat.github.io/tags/c%E5%87%BD%E6%95%B0/"/>
    
      <category term="c++" scheme="https://xuecat.github.io/tags/c/"/>
    
      <category term="stl" scheme="https://xuecat.github.io/tags/stl/"/>
    
  </entry>
  
</feed>
